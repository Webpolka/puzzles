/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./helpers/base-helpers.js":
/*!*********************************!*\
  !*** ./helpers/base-helpers.js ***!
  \*********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseHelpers: function() { return /* binding */ BaseHelpers; }\n/* harmony export */ });\n/* harmony import */ var _mobile_checker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mobile-checker */ \"./helpers/mobile-checker.js\");\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\nconst _BaseHelpers = class _BaseHelpers {\n  /**\n   * Проверка браузера на поддержку .webp изображений\n   * (i) необходимо для корректного отображения webp из css\n   * */\n  static checkWebpSupport() {\n    const testWebp = (callback) => {\n      const webP = new Image();\n      webP.onload = webP.onerror = () => callback(webP.height === 2);\n      webP.src = \"data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA\";\n    };\n    testWebp((support) => {\n      const className = support ? \"webp\" : \"no-webp\";\n      _BaseHelpers.html.classList.add(className);\n      console.log(support ? \"webp \\u043F\\u043E\\u0434\\u0434\\u0435\\u0440\\u0436\\u0438\\u0432\\u0430\\u0435\\u0442\\u0441\\u044F\" : \"webp \\u043D\\u0435 \\u043F\\u043E\\u0434\\u0434\\u0435\\u0440\\u0436\\u0438\\u0432\\u0430\\u0435\\u0442\\u0441\\u044F\");\n    });\n  }\n  /**\n   * Добавление класса touch для HTML если браузер мобильный\n   * */\n  static addTouchClass() {\n    if (_mobile_checker__WEBPACK_IMPORTED_MODULE_0__.MobileChecker.isAny) {\n      _BaseHelpers.html.classList.add(\"touch\");\n    }\n  }\n  /**\n   * Добавление loaded для HTML после полной загрузки страницы\n   * */\n  static addLoadedClass() {\n    window.addEventListener(\"load\", () => {\n      setTimeout(() => {\n        _BaseHelpers.html.classList.add(\"loaded\");\n      }, 0);\n    });\n  }\n  /** Получение хеша в адресе сайта */\n  static get getHash() {\n    var _a;\n    return (_a = location.hash) == null ? void 0 : _a.replace(\"#\", \"\");\n  }\n  /** Указание хеша в адресе сайта */\n  static setHash(hash) {\n    hash = hash ? `#${hash}` : location.href.split(\"#\")[0];\n    history.pushState(\"\", \"\", hash);\n  }\n  /** Функция для фиксированной шапки при скролле */\n  static headerFixed() {\n    const headerStickyObserver = new IntersectionObserver(([entry]) => {\n      _BaseHelpers.html.classList.toggle(\"header-is-sticky\", !entry.isIntersecting);\n    });\n    if (_BaseHelpers.firstScreen) {\n      headerStickyObserver.observe(_BaseHelpers.firstScreen);\n    }\n  }\n  static calcScrollbarWidth() {\n    const scrollbarWidth = (window.innerWidth - document.body.clientWidth) / 16 + \"rem\";\n    _BaseHelpers.html.style.setProperty(\"--bh-scrollbar-width\", scrollbarWidth);\n  }\n};\n__publicField(_BaseHelpers, \"html\", document.documentElement);\n__publicField(_BaseHelpers, \"header\", document.querySelector(\".header\"));\n__publicField(_BaseHelpers, \"firstScreen\", document.querySelector(\"[data-observ]\"));\nlet BaseHelpers = _BaseHelpers;\n\n\n//# sourceURL=webpack:///./helpers/base-helpers.js?");

/***/ }),

/***/ "./helpers/mobile-checker.js":
/*!***********************************!*\
  !*** ./helpers/mobile-checker.js ***!
  \***********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MobileChecker: function() { return /* binding */ MobileChecker; }\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nconst _MobileChecker = class _MobileChecker {\n  /**\n   * Проверяет, является ли устройство Android.\n   * @returns {boolean} true, если устройство Android, в противном случае false.\n   */\n  static get isAndroid() {\n    return Boolean(_MobileChecker.userAgent.match(/Android/i));\n  }\n  /**\n   * Проверяет, является ли устройство BlackBerry.\n   * @returns {boolean} true, если устройство BlackBerry, в противном случае false.\n   */\n  static get isBlackBerry() {\n    return Boolean(_MobileChecker.userAgent.match(/BlackBerry/i));\n  }\n  /**\n   * Проверяет, является ли устройство iOS (iPhone, iPad или iPod).\n   * @returns {boolean} true, если устройство iOS, в противном случае false.\n   */\n  static get isAppleOS() {\n    return Boolean(_MobileChecker.userAgent.match(/iPhone|iPad|iPod/i));\n  }\n  /**\n   * Проверяет, является ли устройство Opera Mini.\n   * @returns {boolean} true, если устройство Opera Mini, в противном случае false.\n   */\n  static get isOpera() {\n    return Boolean(_MobileChecker.userAgent.match(/Opera Mini/i));\n  }\n  /**\n   * Проверяет, является ли устройство Windows.\n   * @returns {boolean} true, если устройство Windows, в противном случае false.\n   */\n  static get isWindows() {\n    return Boolean(_MobileChecker.userAgent.match(/IEMobile/i));\n  }\n  /**\n   * Проверяет, является ли устройство любым из поддерживаемых типов (Android, BlackBerry, iOS, Opera Mini, Windows).\n   * @returns {boolean} true, если устройство является любым из поддерживаемых типов, в противном случае false.\n   */\n  static get isAny() {\n    return _MobileChecker.isAndroid || _MobileChecker.isBlackBerry || _MobileChecker.isAppleOS || _MobileChecker.isOpera || _MobileChecker.isWindows;\n  }\n};\n__publicField(_MobileChecker, \"userAgent\", navigator.userAgent);\nlet MobileChecker = _MobileChecker;\n\n\n//# sourceURL=webpack:///./helpers/mobile-checker.js?");

/***/ }),

/***/ "./main.js":
/*!*****************!*\
  !*** ./main.js ***!
  \*****************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _helpers_base_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers/base-helpers */ \"./helpers/base-helpers.js\");\n/* harmony import */ var _modules_carousel_splide_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/carousel-splide.js */ \"./modules/carousel-splide.js\");\n\n_helpers_base_helpers__WEBPACK_IMPORTED_MODULE_0__.BaseHelpers.addLoadedClass();\n_helpers_base_helpers__WEBPACK_IMPORTED_MODULE_0__.BaseHelpers.checkWebpSupport();\n_helpers_base_helpers__WEBPACK_IMPORTED_MODULE_0__.BaseHelpers.calcScrollbarWidth();\n_helpers_base_helpers__WEBPACK_IMPORTED_MODULE_0__.BaseHelpers.addTouchClass();\n_helpers_base_helpers__WEBPACK_IMPORTED_MODULE_0__.BaseHelpers.headerFixed();\n\n(0,_modules_carousel_splide_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])();\nlet splide = new Splide(\"#images-list\", {\n  type: \"loop\",\n  // (slide, loop, fade) - соответственно (незацикленное, зацикленное, замена путем fade эффекта)\n  direction: \"ltr\",\n  // направление карусели (ltr, rtl, ttb) соответсвенно (слева на право, справа на лево, сверху вниз)\n  drag: false,\n  // разрешать перетаскивать слайдер\n  autoplay: false,\n  // включить авто перелистывание\n  interval: 2e3,\n  // интервал автоматического перелистывания слайдов в м\\сек\n  pauseOnHover: true,\n  // остановить автоматическое перелистывание при наведении курсора мыши\n  perMove: 1,\n  // количество перемещаемых слайдов за раз\n  perPage: 1,\n  // Количество слайдов \n  gap: \"0rem\",\n  // зазор между слайдами\n  height: \"100%\",\n  // высота карусели\n  padding: {\n    // (left, right) - для горизонтальной карусели (top, bottom - для вертикальной карусели)\n    left: 0,\n    right: 0\n  },\n  arrows: true,\n  // отображать стрелки   \n  pagination: false,\n  // отображать пагинацию\n  speed: 500,\n  // скорость перелистывания в м\\сек\n  rewindSpeed: 5e3,\n  // скорость перемотки слайдов\n  rewind: true,\n  // позволяет вообще перемотку слайдов\n  rewindByDrag: true\n  // позволяет делать перемотку слайдов перетаскиванием мыши\n}).mount();\nlet clickSound = document.querySelector(\"#click\");\nlet listSound = document.querySelector(\"#list\");\nlet mixSound = document.querySelector(\"#mix\");\nlet winSound = document.querySelector(\"#win\");\nsplide.on(\"move\", function() {\n  clickSound.play();\n});\nlet allImages = document.querySelector(\"#images-list\").querySelectorAll(\"img\");\nallImages.forEach((pic) => {\n  pic.addEventListener(\"click\", () => {\n    listSound.play();\n    let el = document.querySelector(\".game-wrap\");\n    el.setAttribute(\"style\", `--img-url: url('${pic.src}'`);\n  });\n});\nfullScreen(document.querySelector(\"body\"));\nfunction fullScreen(element) {\n  if (element.requestFullscreen) {\n    element.requestFullscreen();\n  } else if (element.webkitrequestFullscreen) {\n    element.webkitRequestFullscreen();\n  } else if (element.mozRequestFullscreen) {\n    element.mozRequestFullScreen();\n  }\n}\nconst gameNode = document.getElementById(\"game\");\nconst containerNode = document.getElementById(\"puzzles\");\nconst itemNodes = Array.from(containerNode.querySelectorAll(\".item\"));\nconst countItems = 16;\nif (itemNodes.length !== 16) {\n  throw new Error(\"\\u0414\\u043E\\u043B\\u0436\\u043D\\u043E \\u0431\\u044B\\u0442\\u044C \\u0440\\u043E\\u0432\\u043D\\u043E ${countItems} items in Html\");\n}\nitemNodes[countItems - 1].style.display = \"none\";\nlet matrix = getMatrix(itemNodes.map((item) => Number(item.dataset.matrixId)));\nsetPositionItems(matrix);\nconst maxShuffleCount = 70;\nlet timer;\nconst shuffledClassName = \"gameShuffle\";\nlet shuffled = false;\ndocument.getElementById(\"shuffle\").addEventListener(\"click\", () => {\n  mixSound.play();\n  randomSwap(matrix);\n  setPositionItems(matrix);\n  if (shuffled) {\n    return;\n  }\n  shuffled = true;\n  let shuffleCount = 0;\n  gameNode.classList.add(shuffledClassName);\n  if (shuffleCount === 0) {\n    timer = setInterval(() => {\n      randomSwap(matrix);\n      setPositionItems(matrix);\n      shuffleCount += 1;\n      if (shuffleCount >= maxShuffleCount) {\n        gameNode.classList.remove(shuffledClassName);\n        clearInterval(timer);\n        shuffled = false;\n      }\n    }, 50);\n  }\n});\ndocument.getElementById(\"again\").addEventListener(\"click\", () => {\n  clickSound.play();\n  matrix = getMatrix(itemNodes.map((item) => Number(item.dataset.matrixId)));\n  setPositionItems(matrix);\n});\nconst blankNumber = 16;\ncontainerNode.addEventListener(\"click\", (event) => {\n  clickSound.play();\n  const buttonNode = event.target.closest(\"button\");\n  if (shuffled) {\n    return;\n  }\n  if (!buttonNode) {\n    return;\n  }\n  const buttonNumber = Number(buttonNode.dataset.matrixId);\n  const buttonCoords = findCoordinatesByNumber(buttonNumber, matrix);\n  const blankCoords = findCoordinatesByNumber(blankNumber, matrix);\n  const isValid = isValidForSwap(buttonCoords, blankCoords);\n  if (isValid) {\n    swap(blankCoords, buttonCoords, matrix);\n    setPositionItems(matrix);\n  }\n});\nwindow.addEventListener(\"keydown\", (event) => {\n  if (shuffled) {\n    return;\n  }\n  if (!event.key.includes(\"Arrow\")) {\n    return;\n  }\n  const blankCoords = findCoordinatesByNumber(blankNumber, matrix);\n  const buttonCoords = {\n    x: blankCoords.x,\n    y: blankCoords.y\n  };\n  const direction = event.key.split(\"Arrow\")[1].toLowerCase();\n  const maxIndexMatrix = matrix.length;\n  switch (direction) {\n    case \"up\":\n      buttonCoords.y += 1;\n      break;\n    case \"left\":\n      buttonCoords.x += 1;\n      break;\n    case \"down\":\n      buttonCoords.y -= 1;\n      break;\n    case \"right\":\n      buttonCoords.x -= 1;\n      break;\n  }\n  if (buttonCoords.y >= maxIndexMatrix || buttonCoords.y < 0 || buttonCoords.x >= maxIndexMatrix || buttonCoords.x < 0) {\n    return;\n  }\n  swap(blankCoords, buttonCoords, matrix);\n  setPositionItems(matrix);\n});\nlet blockedCoords = null;\nfunction randomSwap(matrix2) {\n  const blankCoords = findCoordinatesByNumber(blankNumber, matrix2);\n  const validCoords = findValidCoords({\n    blankCoords,\n    matrix: matrix2,\n    blockedCoords\n  });\n  const swapCoords = validCoords[Math.floor(Math.random() * validCoords.length)];\n  swap(blankCoords, swapCoords, matrix2);\n  blockedCoords = blankCoords;\n}\nfunction findValidCoords({ blankCoords, matrix: matrix2, blockedCoords: blockedCoords2 }) {\n  const validCoords = [];\n  for (let y = 0; y < matrix2.length; y++) {\n    for (let x = 0; x < matrix2[y].length; x++) {\n      if (isValidForSwap({ x, y }, blankCoords)) {\n        if (!blockedCoords2 || !(blockedCoords2.x === x && blockedCoords2.y === y)) {\n          validCoords.push({ x, y });\n        }\n      }\n    }\n  }\n  return validCoords;\n}\nfunction getMatrix(arr) {\n  const matrix2 = [[], [], [], []];\n  let y = 0;\n  let x = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (x >= 4) {\n      y++;\n      x = 0;\n    }\n    matrix2[y][x] = arr[i];\n    x++;\n  }\n  return matrix2;\n}\nfunction setPositionItems(matrix2) {\n  for (let y = 0; y < matrix2.length; y++) {\n    for (let x = 0; x < matrix2[y].length; x++) {\n      const value = matrix2[y][x];\n      const node = itemNodes[value - 1];\n      setNodeStyles(node, x, y);\n    }\n  }\n}\nfunction setNodeStyles(node, x, y) {\n  const shiftPs = 100;\n  node.style.transform = `translate3D(${x * shiftPs}%, ${y * shiftPs}%, 0)`;\n}\nfunction shuffleArray(arr) {\n  return arr.map((value) => ({ value, sort: Math.random() })).sort((a, b) => a.sort - b.sort).map(({ value }) => value);\n}\nfunction findCoordinatesByNumber(number, matrix2) {\n  for (let y = 0; y < matrix2.length; y++) {\n    for (let x = 0; x < matrix2[y].length; x++) {\n      if (matrix2[y][x] === number) {\n        return { x, y };\n      }\n    }\n  }\n}\nfunction isValidForSwap(coords1, coords2) {\n  const diffX = Math.abs(coords1.x - coords2.x);\n  const diffY = Math.abs(coords1.y - coords2.y);\n  return (diffX === 1 || diffY === 1) && (coords1.x === coords2.x || coords1.y === coords2.y);\n}\nfunction swap(coords1, coords2, matrix2) {\n  const coordsNumber = matrix2[coords1.y][coords1.x];\n  matrix2[coords1.y][coords1.x] = matrix2[coords2.y][coords2.x];\n  matrix2[coords2.y][coords2.x] = coordsNumber;\n  if (isWon(matrix2)) {\n    addWonClass();\n  }\n}\nconst winFlatArr = new Array(16).fill(0).map((_item, i) => i + 1);\nfunction isWon(matrix2) {\n  const flatMatrix = matrix2.flat();\n  for (let i = 0; i < winFlatArr.length; i++) {\n    if (flatMatrix[i] !== winFlatArr[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nconst wonClass = \"puzzlesWon\";\nfunction addWonClass() {\n  winSound.play();\n  setTimeout(() => {\n    containerNode.classList.add(wonClass);\n    setTimeout(() => {\n      containerNode.classList.remove(wonClass);\n    }, 1e3);\n  }, 200);\n}\n\n\n//# sourceURL=webpack:///./main.js?");

/***/ }),

/***/ "./modules/carousel-splide.js":
/*!************************************!*\
  !*** ./modules/carousel-splide.js ***!
  \************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\nfunction carouselSplideInit() {\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", { writable: false });\n    return Constructor;\n  }\n  /*!\n   * Splide.js\n   * Version  : 4.1.2\n   * License  : MIT\n   * Copyright: 2022 Naotoshi Fujita\n   */\n  (function(global, factory) {\n    typeof exports === \"object\" && typeof module !== \"undefined\" ? module.exports = factory() : typeof define === \"function\" && define.amd ? define(factory) : (global = typeof globalThis !== \"undefined\" ? globalThis : global || self, global.Splide = factory());\n  })(this, function() {\n    \"use strict\";\n    var MEDIA_PREFERS_REDUCED_MOTION = \"(prefers-reduced-motion: reduce)\";\n    var CREATED = 1;\n    var MOUNTED = 2;\n    var IDLE = 3;\n    var MOVING = 4;\n    var SCROLLING = 5;\n    var DRAGGING = 6;\n    var DESTROYED = 7;\n    var STATES = {\n      CREATED,\n      MOUNTED,\n      IDLE,\n      MOVING,\n      SCROLLING,\n      DRAGGING,\n      DESTROYED\n    };\n    function empty(array) {\n      array.length = 0;\n    }\n    function slice(arrayLike, start, end) {\n      return Array.prototype.slice.call(arrayLike, start, end);\n    }\n    function apply(func) {\n      return func.bind.apply(func, [null].concat(slice(arguments, 1)));\n    }\n    var nextTick = setTimeout;\n    var noop = function noop2() {\n    };\n    function raf(func) {\n      return requestAnimationFrame(func);\n    }\n    function typeOf(type, subject) {\n      return typeof subject === type;\n    }\n    function isObject(subject) {\n      return !isNull(subject) && typeOf(\"object\", subject);\n    }\n    var isArray = Array.isArray;\n    var isFunction = apply(typeOf, \"function\");\n    var isString = apply(typeOf, \"string\");\n    var isUndefined = apply(typeOf, \"undefined\");\n    function isNull(subject) {\n      return subject === null;\n    }\n    function isHTMLElement(subject) {\n      try {\n        return subject instanceof (subject.ownerDocument.defaultView || window).HTMLElement;\n      } catch (e) {\n        return false;\n      }\n    }\n    function toArray(value) {\n      return isArray(value) ? value : [value];\n    }\n    function forEach(values, iteratee) {\n      toArray(values).forEach(iteratee);\n    }\n    function includes(array, value) {\n      return array.indexOf(value) > -1;\n    }\n    function push(array, items) {\n      array.push.apply(array, toArray(items));\n      return array;\n    }\n    function toggleClass(elm, classes, add) {\n      if (elm) {\n        forEach(classes, function(name) {\n          if (name) {\n            elm.classList[add ? \"add\" : \"remove\"](name);\n          }\n        });\n      }\n    }\n    function addClass(elm, classes) {\n      toggleClass(elm, isString(classes) ? classes.split(\" \") : classes, true);\n    }\n    function append(parent, children2) {\n      forEach(children2, parent.appendChild.bind(parent));\n    }\n    function before(nodes, ref) {\n      forEach(nodes, function(node) {\n        var parent = (ref || node).parentNode;\n        if (parent) {\n          parent.insertBefore(node, ref);\n        }\n      });\n    }\n    function matches(elm, selector) {\n      return isHTMLElement(elm) && (elm[\"msMatchesSelector\"] || elm.matches).call(elm, selector);\n    }\n    function children(parent, selector) {\n      var children2 = parent ? slice(parent.children) : [];\n      return selector ? children2.filter(function(child2) {\n        return matches(child2, selector);\n      }) : children2;\n    }\n    function child(parent, selector) {\n      return selector ? children(parent, selector)[0] : parent.firstElementChild;\n    }\n    var ownKeys = Object.keys;\n    function forOwn(object, iteratee, right) {\n      if (object) {\n        (right ? ownKeys(object).reverse() : ownKeys(object)).forEach(function(key) {\n          key !== \"__proto__\" && iteratee(object[key], key);\n        });\n      }\n      return object;\n    }\n    function assign(object) {\n      slice(arguments, 1).forEach(function(source) {\n        forOwn(source, function(value, key) {\n          object[key] = source[key];\n        });\n      });\n      return object;\n    }\n    function merge(object) {\n      slice(arguments, 1).forEach(function(source) {\n        forOwn(source, function(value, key) {\n          if (isArray(value)) {\n            object[key] = value.slice();\n          } else if (isObject(value)) {\n            object[key] = merge({}, isObject(object[key]) ? object[key] : {}, value);\n          } else {\n            object[key] = value;\n          }\n        });\n      });\n      return object;\n    }\n    function omit(object, keys) {\n      forEach(keys || ownKeys(object), function(key) {\n        delete object[key];\n      });\n    }\n    function removeAttribute(elms, attrs) {\n      forEach(elms, function(elm) {\n        forEach(attrs, function(attr) {\n          elm && elm.removeAttribute(attr);\n        });\n      });\n    }\n    function setAttribute(elms, attrs, value) {\n      if (isObject(attrs)) {\n        forOwn(attrs, function(value2, name) {\n          setAttribute(elms, name, value2);\n        });\n      } else {\n        forEach(elms, function(elm) {\n          isNull(value) || value === \"\" ? removeAttribute(elm, attrs) : elm.setAttribute(attrs, String(value));\n        });\n      }\n    }\n    function create(tag, attrs, parent) {\n      var elm = document.createElement(tag);\n      if (attrs) {\n        isString(attrs) ? addClass(elm, attrs) : setAttribute(elm, attrs);\n      }\n      parent && append(parent, elm);\n      return elm;\n    }\n    function style(elm, prop, value) {\n      if (isUndefined(value)) {\n        return getComputedStyle(elm)[prop];\n      }\n      if (!isNull(value)) {\n        elm.style[prop] = \"\" + value;\n      }\n    }\n    function display(elm, display2) {\n      style(elm, \"display\", display2);\n    }\n    function focus(elm) {\n      elm[\"setActive\"] && elm[\"setActive\"]() || elm.focus({\n        preventScroll: true\n      });\n    }\n    function getAttribute(elm, attr) {\n      return elm.getAttribute(attr);\n    }\n    function hasClass(elm, className) {\n      return elm && elm.classList.contains(className);\n    }\n    function rect(target) {\n      return target.getBoundingClientRect();\n    }\n    function remove(nodes) {\n      forEach(nodes, function(node) {\n        if (node && node.parentNode) {\n          node.parentNode.removeChild(node);\n        }\n      });\n    }\n    function parseHtml(html) {\n      return child(new DOMParser().parseFromString(html, \"text/html\").body);\n    }\n    function prevent(e, stopPropagation) {\n      e.preventDefault();\n      if (stopPropagation) {\n        e.stopPropagation();\n        e.stopImmediatePropagation();\n      }\n    }\n    function query(parent, selector) {\n      return parent && parent.querySelector(selector);\n    }\n    function queryAll(parent, selector) {\n      return selector ? slice(parent.querySelectorAll(selector)) : [];\n    }\n    function removeClass(elm, classes) {\n      toggleClass(elm, classes, false);\n    }\n    function timeOf(e) {\n      return e.timeStamp;\n    }\n    function unit(value) {\n      return isString(value) ? value : value ? value + \"px\" : \"\";\n    }\n    var PROJECT_CODE = \"splide\";\n    var DATA_ATTRIBUTE = \"data-\" + PROJECT_CODE;\n    function assert(condition, message) {\n      if (!condition) {\n        throw new Error(\"[\" + PROJECT_CODE + \"] \" + (message || \"\"));\n      }\n    }\n    var min = Math.min, max = Math.max, floor = Math.floor, ceil = Math.ceil, abs = Math.abs;\n    function approximatelyEqual(x, y, epsilon) {\n      return abs(x - y) < epsilon;\n    }\n    function between(number, x, y, exclusive) {\n      var minimum = min(x, y);\n      var maximum = max(x, y);\n      return exclusive ? minimum < number && number < maximum : minimum <= number && number <= maximum;\n    }\n    function clamp(number, x, y) {\n      var minimum = min(x, y);\n      var maximum = max(x, y);\n      return min(max(minimum, number), maximum);\n    }\n    function sign(x) {\n      return +(x > 0) - +(x < 0);\n    }\n    function format(string, replacements) {\n      forEach(replacements, function(replacement) {\n        string = string.replace(\"%s\", \"\" + replacement);\n      });\n      return string;\n    }\n    function pad(number) {\n      return number < 10 ? \"0\" + number : \"\" + number;\n    }\n    var ids = {};\n    function uniqueId(prefix) {\n      return \"\" + prefix + pad(ids[prefix] = (ids[prefix] || 0) + 1);\n    }\n    function EventBinder() {\n      var listeners = [];\n      function bind(targets, events, callback, options) {\n        forEachEvent(targets, events, function(target, event, namespace) {\n          var isEventTarget = \"addEventListener\" in target;\n          var remover = isEventTarget ? target.removeEventListener.bind(target, event, callback, options) : target[\"removeListener\"].bind(target, callback);\n          isEventTarget ? target.addEventListener(event, callback, options) : target[\"addListener\"](callback);\n          listeners.push([target, event, namespace, callback, remover]);\n        });\n      }\n      function unbind(targets, events, callback) {\n        forEachEvent(targets, events, function(target, event, namespace) {\n          listeners = listeners.filter(function(listener) {\n            if (listener[0] === target && listener[1] === event && listener[2] === namespace && (!callback || listener[3] === callback)) {\n              listener[4]();\n              return false;\n            }\n            return true;\n          });\n        });\n      }\n      function dispatch(target, type, detail) {\n        var e;\n        var bubbles = true;\n        if (typeof CustomEvent === \"function\") {\n          e = new CustomEvent(type, {\n            bubbles,\n            detail\n          });\n        } else {\n          e = document.createEvent(\"CustomEvent\");\n          e.initCustomEvent(type, bubbles, false, detail);\n        }\n        target.dispatchEvent(e);\n        return e;\n      }\n      function forEachEvent(targets, events, iteratee) {\n        forEach(targets, function(target) {\n          target && forEach(events, function(events2) {\n            events2.split(\" \").forEach(function(eventNS) {\n              var fragment = eventNS.split(\".\");\n              iteratee(target, fragment[0], fragment[1]);\n            });\n          });\n        });\n      }\n      function destroy() {\n        listeners.forEach(function(data) {\n          data[4]();\n        });\n        empty(listeners);\n      }\n      return {\n        bind,\n        unbind,\n        dispatch,\n        destroy\n      };\n    }\n    var EVENT_MOUNTED = \"mounted\";\n    var EVENT_READY = \"ready\";\n    var EVENT_MOVE = \"move\";\n    var EVENT_MOVED = \"moved\";\n    var EVENT_CLICK = \"click\";\n    var EVENT_ACTIVE = \"active\";\n    var EVENT_INACTIVE = \"inactive\";\n    var EVENT_VISIBLE = \"visible\";\n    var EVENT_HIDDEN = \"hidden\";\n    var EVENT_REFRESH = \"refresh\";\n    var EVENT_UPDATED = \"updated\";\n    var EVENT_RESIZE = \"resize\";\n    var EVENT_RESIZED = \"resized\";\n    var EVENT_DRAG = \"drag\";\n    var EVENT_DRAGGING = \"dragging\";\n    var EVENT_DRAGGED = \"dragged\";\n    var EVENT_SCROLL = \"scroll\";\n    var EVENT_SCROLLED = \"scrolled\";\n    var EVENT_OVERFLOW = \"overflow\";\n    var EVENT_DESTROY = \"destroy\";\n    var EVENT_ARROWS_MOUNTED = \"arrows:mounted\";\n    var EVENT_ARROWS_UPDATED = \"arrows:updated\";\n    var EVENT_PAGINATION_MOUNTED = \"pagination:mounted\";\n    var EVENT_PAGINATION_UPDATED = \"pagination:updated\";\n    var EVENT_NAVIGATION_MOUNTED = \"navigation:mounted\";\n    var EVENT_AUTOPLAY_PLAY = \"autoplay:play\";\n    var EVENT_AUTOPLAY_PLAYING = \"autoplay:playing\";\n    var EVENT_AUTOPLAY_PAUSE = \"autoplay:pause\";\n    var EVENT_LAZYLOAD_LOADED = \"lazyload:loaded\";\n    var EVENT_SLIDE_KEYDOWN = \"sk\";\n    var EVENT_SHIFTED = \"sh\";\n    var EVENT_END_INDEX_CHANGED = \"ei\";\n    function EventInterface(Splide2) {\n      var bus = Splide2 ? Splide2.event.bus : document.createDocumentFragment();\n      var binder = EventBinder();\n      function on(events, callback) {\n        binder.bind(bus, toArray(events).join(\" \"), function(e) {\n          callback.apply(callback, isArray(e.detail) ? e.detail : []);\n        });\n      }\n      function emit(event) {\n        binder.dispatch(bus, event, slice(arguments, 1));\n      }\n      if (Splide2) {\n        Splide2.event.on(EVENT_DESTROY, binder.destroy);\n      }\n      return assign(binder, {\n        bus,\n        on,\n        off: apply(binder.unbind, bus),\n        emit\n      });\n    }\n    function RequestInterval(interval, onInterval, onUpdate, limit) {\n      var now = Date.now;\n      var startTime;\n      var rate = 0;\n      var id;\n      var paused = true;\n      var count = 0;\n      function update() {\n        if (!paused) {\n          rate = interval ? min((now() - startTime) / interval, 1) : 1;\n          onUpdate && onUpdate(rate);\n          if (rate >= 1) {\n            onInterval();\n            startTime = now();\n            if (limit && ++count >= limit) {\n              return pause();\n            }\n          }\n          id = raf(update);\n        }\n      }\n      function start(resume) {\n        resume || cancel();\n        startTime = now() - (resume ? rate * interval : 0);\n        paused = false;\n        id = raf(update);\n      }\n      function pause() {\n        paused = true;\n      }\n      function rewind() {\n        startTime = now();\n        rate = 0;\n        if (onUpdate) {\n          onUpdate(rate);\n        }\n      }\n      function cancel() {\n        id && cancelAnimationFrame(id);\n        rate = 0;\n        id = 0;\n        paused = true;\n      }\n      function set(time) {\n        interval = time;\n      }\n      function isPaused() {\n        return paused;\n      }\n      return {\n        start,\n        rewind,\n        pause,\n        cancel,\n        set,\n        isPaused\n      };\n    }\n    function State(initialState) {\n      var state = initialState;\n      function set(value) {\n        state = value;\n      }\n      function is(states) {\n        return includes(toArray(states), state);\n      }\n      return {\n        set,\n        is\n      };\n    }\n    function Throttle(func, duration) {\n      var interval = RequestInterval(duration || 0, func, null, 1);\n      return function() {\n        interval.isPaused() && interval.start();\n      };\n    }\n    function Media(Splide2, Components2, options) {\n      var state = Splide2.state;\n      var breakpoints = options.breakpoints || {};\n      var reducedMotion = options.reducedMotion || {};\n      var binder = EventBinder();\n      var queries = [];\n      function setup() {\n        var isMin = options.mediaQuery === \"min\";\n        ownKeys(breakpoints).sort(function(n, m) {\n          return isMin ? +n - +m : +m - +n;\n        }).forEach(function(key) {\n          register(breakpoints[key], \"(\" + (isMin ? \"min\" : \"max\") + \"-width:\" + key + \"px)\");\n        });\n        register(reducedMotion, MEDIA_PREFERS_REDUCED_MOTION);\n        update();\n      }\n      function destroy(completely) {\n        if (completely) {\n          binder.destroy();\n        }\n      }\n      function register(options2, query2) {\n        var queryList = matchMedia(query2);\n        binder.bind(queryList, \"change\", update);\n        queries.push([options2, queryList]);\n      }\n      function update() {\n        var destroyed = state.is(DESTROYED);\n        var direction = options.direction;\n        var merged = queries.reduce(function(merged2, entry) {\n          return merge(merged2, entry[1].matches ? entry[0] : {});\n        }, {});\n        omit(options);\n        set(merged);\n        if (options.destroy) {\n          Splide2.destroy(options.destroy === \"completely\");\n        } else if (destroyed) {\n          destroy(true);\n          Splide2.mount();\n        } else {\n          direction !== options.direction && Splide2.refresh();\n        }\n      }\n      function reduce(enable) {\n        if (matchMedia(MEDIA_PREFERS_REDUCED_MOTION).matches) {\n          enable ? merge(options, reducedMotion) : omit(options, ownKeys(reducedMotion));\n        }\n      }\n      function set(opts, base, notify) {\n        merge(options, opts);\n        base && merge(Object.getPrototypeOf(options), opts);\n        if (notify || !state.is(CREATED)) {\n          Splide2.emit(EVENT_UPDATED, options);\n        }\n      }\n      return {\n        setup,\n        destroy,\n        reduce,\n        set\n      };\n    }\n    var ARROW = \"Arrow\";\n    var ARROW_LEFT = ARROW + \"Left\";\n    var ARROW_RIGHT = ARROW + \"Right\";\n    var ARROW_UP = ARROW + \"Up\";\n    var ARROW_DOWN = ARROW + \"Down\";\n    var RTL = \"rtl\";\n    var TTB = \"ttb\";\n    var ORIENTATION_MAP = {\n      width: [\"height\"],\n      left: [\"top\", \"right\"],\n      right: [\"bottom\", \"left\"],\n      x: [\"y\"],\n      X: [\"Y\"],\n      Y: [\"X\"],\n      ArrowLeft: [ARROW_UP, ARROW_RIGHT],\n      ArrowRight: [ARROW_DOWN, ARROW_LEFT]\n    };\n    function Direction(Splide2, Components2, options) {\n      function resolve(prop, axisOnly, direction) {\n        direction = direction || options.direction;\n        var index = direction === RTL && !axisOnly ? 1 : direction === TTB ? 0 : -1;\n        return ORIENTATION_MAP[prop] && ORIENTATION_MAP[prop][index] || prop.replace(/width|left|right/i, function(match, offset) {\n          var replacement = ORIENTATION_MAP[match.toLowerCase()][index] || match;\n          return offset > 0 ? replacement.charAt(0).toUpperCase() + replacement.slice(1) : replacement;\n        });\n      }\n      function orient(value) {\n        return value * (options.direction === RTL ? 1 : -1);\n      }\n      return {\n        resolve,\n        orient\n      };\n    }\n    var ROLE = \"role\";\n    var TAB_INDEX = \"tabindex\";\n    var DISABLED = \"disabled\";\n    var ARIA_PREFIX = \"aria-\";\n    var ARIA_CONTROLS = ARIA_PREFIX + \"controls\";\n    var ARIA_CURRENT = ARIA_PREFIX + \"current\";\n    var ARIA_SELECTED = ARIA_PREFIX + \"selected\";\n    var ARIA_LABEL = ARIA_PREFIX + \"label\";\n    var ARIA_LABELLEDBY = ARIA_PREFIX + \"labelledby\";\n    var ARIA_HIDDEN = ARIA_PREFIX + \"hidden\";\n    var ARIA_ORIENTATION = ARIA_PREFIX + \"orientation\";\n    var ARIA_ROLEDESCRIPTION = ARIA_PREFIX + \"roledescription\";\n    var ARIA_LIVE = ARIA_PREFIX + \"live\";\n    var ARIA_BUSY = ARIA_PREFIX + \"busy\";\n    var ARIA_ATOMIC = ARIA_PREFIX + \"atomic\";\n    var ALL_ATTRIBUTES = [ROLE, TAB_INDEX, DISABLED, ARIA_CONTROLS, ARIA_CURRENT, ARIA_LABEL, ARIA_LABELLEDBY, ARIA_HIDDEN, ARIA_ORIENTATION, ARIA_ROLEDESCRIPTION];\n    var CLASS_PREFIX = PROJECT_CODE + \"__\";\n    var STATUS_CLASS_PREFIX = \"is-\";\n    var CLASS_ROOT = PROJECT_CODE;\n    var CLASS_TRACK = CLASS_PREFIX + \"track\";\n    var CLASS_LIST = CLASS_PREFIX + \"list\";\n    var CLASS_SLIDE = CLASS_PREFIX + \"slide\";\n    var CLASS_CLONE = CLASS_SLIDE + \"--clone\";\n    var CLASS_CONTAINER = CLASS_SLIDE + \"__container\";\n    var CLASS_ARROWS = CLASS_PREFIX + \"arrows\";\n    var CLASS_ARROW = CLASS_PREFIX + \"arrow\";\n    var CLASS_ARROW_PREV = CLASS_ARROW + \"--prev\";\n    var CLASS_ARROW_NEXT = CLASS_ARROW + \"--next\";\n    var CLASS_PAGINATION = CLASS_PREFIX + \"pagination\";\n    var CLASS_PAGINATION_PAGE = CLASS_PAGINATION + \"__page\";\n    var CLASS_PROGRESS = CLASS_PREFIX + \"progress\";\n    var CLASS_PROGRESS_BAR = CLASS_PROGRESS + \"__bar\";\n    var CLASS_TOGGLE = CLASS_PREFIX + \"toggle\";\n    var CLASS_SPINNER = CLASS_PREFIX + \"spinner\";\n    var CLASS_SR = CLASS_PREFIX + \"sr\";\n    var CLASS_INITIALIZED = STATUS_CLASS_PREFIX + \"initialized\";\n    var CLASS_ACTIVE = STATUS_CLASS_PREFIX + \"active\";\n    var CLASS_PREV = STATUS_CLASS_PREFIX + \"prev\";\n    var CLASS_NEXT = STATUS_CLASS_PREFIX + \"next\";\n    var CLASS_VISIBLE = STATUS_CLASS_PREFIX + \"visible\";\n    var CLASS_LOADING = STATUS_CLASS_PREFIX + \"loading\";\n    var CLASS_FOCUS_IN = STATUS_CLASS_PREFIX + \"focus-in\";\n    var CLASS_OVERFLOW = STATUS_CLASS_PREFIX + \"overflow\";\n    var STATUS_CLASSES = [CLASS_ACTIVE, CLASS_VISIBLE, CLASS_PREV, CLASS_NEXT, CLASS_LOADING, CLASS_FOCUS_IN, CLASS_OVERFLOW];\n    var CLASSES = {\n      slide: CLASS_SLIDE,\n      clone: CLASS_CLONE,\n      arrows: CLASS_ARROWS,\n      arrow: CLASS_ARROW,\n      prev: CLASS_ARROW_PREV,\n      next: CLASS_ARROW_NEXT,\n      pagination: CLASS_PAGINATION,\n      page: CLASS_PAGINATION_PAGE,\n      spinner: CLASS_SPINNER\n    };\n    function closest(from, selector) {\n      if (isFunction(from.closest)) {\n        return from.closest(selector);\n      }\n      var elm = from;\n      while (elm && elm.nodeType === 1) {\n        if (matches(elm, selector)) {\n          break;\n        }\n        elm = elm.parentElement;\n      }\n      return elm;\n    }\n    var FRICTION = 5;\n    var LOG_INTERVAL = 200;\n    var POINTER_DOWN_EVENTS = \"touchstart mousedown\";\n    var POINTER_MOVE_EVENTS = \"touchmove mousemove\";\n    var POINTER_UP_EVENTS = \"touchend touchcancel mouseup click\";\n    function Elements(Splide2, Components2, options) {\n      var _EventInterface = EventInterface(Splide2), on = _EventInterface.on, bind = _EventInterface.bind;\n      var root = Splide2.root;\n      var i18n = options.i18n;\n      var elements = {};\n      var slides = [];\n      var rootClasses = [];\n      var trackClasses = [];\n      var track;\n      var list;\n      var isUsingKey;\n      function setup() {\n        collect();\n        init();\n        update();\n      }\n      function mount() {\n        on(EVENT_REFRESH, destroy);\n        on(EVENT_REFRESH, setup);\n        on(EVENT_UPDATED, update);\n        bind(document, POINTER_DOWN_EVENTS + \" keydown\", function(e) {\n          isUsingKey = e.type === \"keydown\";\n        }, {\n          capture: true\n        });\n        bind(root, \"focusin\", function() {\n          toggleClass(root, CLASS_FOCUS_IN, !!isUsingKey);\n        });\n      }\n      function destroy(completely) {\n        var attrs = ALL_ATTRIBUTES.concat(\"style\");\n        empty(slides);\n        removeClass(root, rootClasses);\n        removeClass(track, trackClasses);\n        removeAttribute([track, list], attrs);\n        removeAttribute(root, completely ? attrs : [\"style\", ARIA_ROLEDESCRIPTION]);\n      }\n      function update() {\n        removeClass(root, rootClasses);\n        removeClass(track, trackClasses);\n        rootClasses = getClasses(CLASS_ROOT);\n        trackClasses = getClasses(CLASS_TRACK);\n        addClass(root, rootClasses);\n        addClass(track, trackClasses);\n        setAttribute(root, ARIA_LABEL, options.label);\n        setAttribute(root, ARIA_LABELLEDBY, options.labelledby);\n      }\n      function collect() {\n        track = find(\".\" + CLASS_TRACK);\n        list = child(track, \".\" + CLASS_LIST);\n        assert(track && list, \"A track/list element is missing.\");\n        push(slides, children(list, \".\" + CLASS_SLIDE + \":not(.\" + CLASS_CLONE + \")\"));\n        forOwn({\n          arrows: CLASS_ARROWS,\n          pagination: CLASS_PAGINATION,\n          prev: CLASS_ARROW_PREV,\n          next: CLASS_ARROW_NEXT,\n          bar: CLASS_PROGRESS_BAR,\n          toggle: CLASS_TOGGLE\n        }, function(className, key) {\n          elements[key] = find(\".\" + className);\n        });\n        assign(elements, {\n          root,\n          track,\n          list,\n          slides\n        });\n      }\n      function init() {\n        var id = root.id || uniqueId(PROJECT_CODE);\n        var role = options.role;\n        root.id = id;\n        track.id = track.id || id + \"-track\";\n        list.id = list.id || id + \"-list\";\n        if (!getAttribute(root, ROLE) && root.tagName !== \"SECTION\" && role) {\n          setAttribute(root, ROLE, role);\n        }\n        setAttribute(root, ARIA_ROLEDESCRIPTION, i18n.carousel);\n        setAttribute(list, ROLE, \"presentation\");\n      }\n      function find(selector) {\n        var elm = query(root, selector);\n        return elm && closest(elm, \".\" + CLASS_ROOT) === root ? elm : void 0;\n      }\n      function getClasses(base) {\n        return [base + \"--\" + options.type, base + \"--\" + options.direction, options.drag && base + \"--draggable\", options.isNavigation && base + \"--nav\", base === CLASS_ROOT && CLASS_ACTIVE];\n      }\n      return assign(elements, {\n        setup,\n        mount,\n        destroy\n      });\n    }\n    var SLIDE = \"slide\";\n    var LOOP = \"loop\";\n    var FADE = \"fade\";\n    function Slide$1(Splide2, index, slideIndex, slide) {\n      var event = EventInterface(Splide2);\n      var on = event.on, emit = event.emit, bind = event.bind;\n      var Components = Splide2.Components, root = Splide2.root, options = Splide2.options;\n      var isNavigation = options.isNavigation, updateOnMove = options.updateOnMove, i18n = options.i18n, pagination = options.pagination, slideFocus = options.slideFocus;\n      var resolve = Components.Direction.resolve;\n      var styles = getAttribute(slide, \"style\");\n      var label = getAttribute(slide, ARIA_LABEL);\n      var isClone = slideIndex > -1;\n      var container = child(slide, \".\" + CLASS_CONTAINER);\n      var destroyed;\n      function mount() {\n        if (!isClone) {\n          slide.id = root.id + \"-slide\" + pad(index + 1);\n          setAttribute(slide, ROLE, pagination ? \"tabpanel\" : \"group\");\n          setAttribute(slide, ARIA_ROLEDESCRIPTION, i18n.slide);\n          setAttribute(slide, ARIA_LABEL, label || format(i18n.slideLabel, [index + 1, Splide2.length]));\n        }\n        listen();\n      }\n      function listen() {\n        bind(slide, \"click\", apply(emit, EVENT_CLICK, self2));\n        bind(slide, \"keydown\", apply(emit, EVENT_SLIDE_KEYDOWN, self2));\n        on([EVENT_MOVED, EVENT_SHIFTED, EVENT_SCROLLED], update);\n        on(EVENT_NAVIGATION_MOUNTED, initNavigation);\n        if (updateOnMove) {\n          on(EVENT_MOVE, onMove);\n        }\n      }\n      function destroy() {\n        destroyed = true;\n        event.destroy();\n        removeClass(slide, STATUS_CLASSES);\n        removeAttribute(slide, ALL_ATTRIBUTES);\n        setAttribute(slide, \"style\", styles);\n        setAttribute(slide, ARIA_LABEL, label || \"\");\n      }\n      function initNavigation() {\n        var controls = Splide2.splides.map(function(target) {\n          var Slide2 = target.splide.Components.Slides.getAt(index);\n          return Slide2 ? Slide2.slide.id : \"\";\n        }).join(\" \");\n        setAttribute(slide, ARIA_LABEL, format(i18n.slideX, (isClone ? slideIndex : index) + 1));\n        setAttribute(slide, ARIA_CONTROLS, controls);\n        setAttribute(slide, ROLE, slideFocus ? \"button\" : \"\");\n        slideFocus && removeAttribute(slide, ARIA_ROLEDESCRIPTION);\n      }\n      function onMove() {\n        if (!destroyed) {\n          update();\n        }\n      }\n      function update() {\n        if (!destroyed) {\n          var curr = Splide2.index;\n          updateActivity();\n          updateVisibility();\n          toggleClass(slide, CLASS_PREV, index === curr - 1);\n          toggleClass(slide, CLASS_NEXT, index === curr + 1);\n        }\n      }\n      function updateActivity() {\n        var active = isActive();\n        if (active !== hasClass(slide, CLASS_ACTIVE)) {\n          toggleClass(slide, CLASS_ACTIVE, active);\n          setAttribute(slide, ARIA_CURRENT, isNavigation && active || \"\");\n          emit(active ? EVENT_ACTIVE : EVENT_INACTIVE, self2);\n        }\n      }\n      function updateVisibility() {\n        var visible = isVisible();\n        var hidden = !visible && (!isActive() || isClone);\n        if (!Splide2.state.is([MOVING, SCROLLING])) {\n          setAttribute(slide, ARIA_HIDDEN, hidden || \"\");\n        }\n        setAttribute(queryAll(slide, options.focusableNodes || \"\"), TAB_INDEX, hidden ? -1 : \"\");\n        if (slideFocus) {\n          setAttribute(slide, TAB_INDEX, hidden ? -1 : 0);\n        }\n        if (visible !== hasClass(slide, CLASS_VISIBLE)) {\n          toggleClass(slide, CLASS_VISIBLE, visible);\n          emit(visible ? EVENT_VISIBLE : EVENT_HIDDEN, self2);\n        }\n        if (!visible && document.activeElement === slide) {\n          var Slide2 = Components.Slides.getAt(Splide2.index);\n          Slide2 && focus(Slide2.slide);\n        }\n      }\n      function style$1(prop, value, useContainer) {\n        style(useContainer && container || slide, prop, value);\n      }\n      function isActive() {\n        var curr = Splide2.index;\n        return curr === index || options.cloneStatus && curr === slideIndex;\n      }\n      function isVisible() {\n        if (Splide2.is(FADE)) {\n          return isActive();\n        }\n        var trackRect = rect(Components.Elements.track);\n        var slideRect = rect(slide);\n        var left = resolve(\"left\", true);\n        var right = resolve(\"right\", true);\n        return floor(trackRect[left]) <= ceil(slideRect[left]) && floor(slideRect[right]) <= ceil(trackRect[right]);\n      }\n      function isWithin(from, distance) {\n        var diff = abs(from - index);\n        if (!isClone && (options.rewind || Splide2.is(LOOP))) {\n          diff = min(diff, Splide2.length - diff);\n        }\n        return diff <= distance;\n      }\n      var self2 = {\n        index,\n        slideIndex,\n        slide,\n        container,\n        isClone,\n        mount,\n        destroy,\n        update,\n        style: style$1,\n        isWithin\n      };\n      return self2;\n    }\n    function Slides(Splide2, Components2, options) {\n      var _EventInterface2 = EventInterface(Splide2), on = _EventInterface2.on, emit = _EventInterface2.emit, bind = _EventInterface2.bind;\n      var _Components2$Elements = Components2.Elements, slides = _Components2$Elements.slides, list = _Components2$Elements.list;\n      var Slides2 = [];\n      function mount() {\n        init();\n        on(EVENT_REFRESH, destroy);\n        on(EVENT_REFRESH, init);\n      }\n      function init() {\n        slides.forEach(function(slide, index) {\n          register(slide, index, -1);\n        });\n      }\n      function destroy() {\n        forEach$1(function(Slide2) {\n          Slide2.destroy();\n        });\n        empty(Slides2);\n      }\n      function update() {\n        forEach$1(function(Slide2) {\n          Slide2.update();\n        });\n      }\n      function register(slide, index, slideIndex) {\n        var object = Slide$1(Splide2, index, slideIndex, slide);\n        object.mount();\n        Slides2.push(object);\n        Slides2.sort(function(Slide1, Slide2) {\n          return Slide1.index - Slide2.index;\n        });\n      }\n      function get(excludeClones) {\n        return excludeClones ? filter(function(Slide2) {\n          return !Slide2.isClone;\n        }) : Slides2;\n      }\n      function getIn(page) {\n        var Controller2 = Components2.Controller;\n        var index = Controller2.toIndex(page);\n        var max2 = Controller2.hasFocus() ? 1 : options.perPage;\n        return filter(function(Slide2) {\n          return between(Slide2.index, index, index + max2 - 1);\n        });\n      }\n      function getAt(index) {\n        return filter(index)[0];\n      }\n      function add(items, index) {\n        forEach(items, function(slide) {\n          if (isString(slide)) {\n            slide = parseHtml(slide);\n          }\n          if (isHTMLElement(slide)) {\n            var ref = slides[index];\n            ref ? before(slide, ref) : append(list, slide);\n            addClass(slide, options.classes.slide);\n            observeImages(slide, apply(emit, EVENT_RESIZE));\n          }\n        });\n        emit(EVENT_REFRESH);\n      }\n      function remove$1(matcher) {\n        remove(filter(matcher).map(function(Slide2) {\n          return Slide2.slide;\n        }));\n        emit(EVENT_REFRESH);\n      }\n      function forEach$1(iteratee, excludeClones) {\n        get(excludeClones).forEach(iteratee);\n      }\n      function filter(matcher) {\n        return Slides2.filter(isFunction(matcher) ? matcher : function(Slide2) {\n          return isString(matcher) ? matches(Slide2.slide, matcher) : includes(toArray(matcher), Slide2.index);\n        });\n      }\n      function style2(prop, value, useContainer) {\n        forEach$1(function(Slide2) {\n          Slide2.style(prop, value, useContainer);\n        });\n      }\n      function observeImages(elm, callback) {\n        var images = queryAll(elm, \"img\");\n        var length = images.length;\n        if (length) {\n          images.forEach(function(img) {\n            bind(img, \"load error\", function() {\n              if (!--length) {\n                callback();\n              }\n            });\n          });\n        } else {\n          callback();\n        }\n      }\n      function getLength(excludeClones) {\n        return excludeClones ? slides.length : Slides2.length;\n      }\n      function isEnough() {\n        return Slides2.length > options.perPage;\n      }\n      return {\n        mount,\n        destroy,\n        update,\n        register,\n        get,\n        getIn,\n        getAt,\n        add,\n        remove: remove$1,\n        forEach: forEach$1,\n        filter,\n        style: style2,\n        getLength,\n        isEnough\n      };\n    }\n    function Layout(Splide2, Components2, options) {\n      var _EventInterface3 = EventInterface(Splide2), on = _EventInterface3.on, bind = _EventInterface3.bind, emit = _EventInterface3.emit;\n      var Slides2 = Components2.Slides;\n      var resolve = Components2.Direction.resolve;\n      var _Components2$Elements2 = Components2.Elements, root = _Components2$Elements2.root, track = _Components2$Elements2.track, list = _Components2$Elements2.list;\n      var getAt = Slides2.getAt, styleSlides = Slides2.style;\n      var vertical;\n      var rootRect;\n      var overflow;\n      function mount() {\n        init();\n        bind(window, \"resize load\", Throttle(apply(emit, EVENT_RESIZE)));\n        on([EVENT_UPDATED, EVENT_REFRESH], init);\n        on(EVENT_RESIZE, resize);\n      }\n      function init() {\n        vertical = options.direction === TTB;\n        style(root, \"maxWidth\", unit(options.width));\n        style(track, resolve(\"paddingLeft\"), cssPadding(false));\n        style(track, resolve(\"paddingRight\"), cssPadding(true));\n        resize(true);\n      }\n      function resize(force) {\n        var newRect = rect(root);\n        if (force || rootRect.width !== newRect.width || rootRect.height !== newRect.height) {\n          style(track, \"height\", cssTrackHeight());\n          styleSlides(resolve(\"marginRight\"), unit(options.gap));\n          styleSlides(\"width\", cssSlideWidth());\n          styleSlides(\"height\", cssSlideHeight(), true);\n          rootRect = newRect;\n          emit(EVENT_RESIZED);\n          if (overflow !== (overflow = isOverflow())) {\n            toggleClass(root, CLASS_OVERFLOW, overflow);\n            emit(EVENT_OVERFLOW, overflow);\n          }\n        }\n      }\n      function cssPadding(right) {\n        var padding = options.padding;\n        var prop = resolve(right ? \"right\" : \"left\");\n        return padding && unit(padding[prop] || (isObject(padding) ? 0 : padding)) || \"0px\";\n      }\n      function cssTrackHeight() {\n        var height = \"\";\n        if (vertical) {\n          height = cssHeight();\n          assert(height, \"height or heightRatio is missing.\");\n          height = \"calc(\" + height + \" - \" + cssPadding(false) + \" - \" + cssPadding(true) + \")\";\n        }\n        return height;\n      }\n      function cssHeight() {\n        return unit(options.height || rect(list).width * options.heightRatio);\n      }\n      function cssSlideWidth() {\n        return options.autoWidth ? null : unit(options.fixedWidth) || (vertical ? \"\" : cssSlideSize());\n      }\n      function cssSlideHeight() {\n        return unit(options.fixedHeight) || (vertical ? options.autoHeight ? null : cssSlideSize() : cssHeight());\n      }\n      function cssSlideSize() {\n        var gap = unit(options.gap);\n        return \"calc((100%\" + (gap && \" + \" + gap) + \")/\" + (options.perPage || 1) + (gap && \" - \" + gap) + \")\";\n      }\n      function listSize() {\n        return rect(list)[resolve(\"width\")];\n      }\n      function slideSize(index, withoutGap) {\n        var Slide2 = getAt(index || 0);\n        return Slide2 ? rect(Slide2.slide)[resolve(\"width\")] + (withoutGap ? 0 : getGap()) : 0;\n      }\n      function totalSize(index, withoutGap) {\n        var Slide2 = getAt(index);\n        if (Slide2) {\n          var right = rect(Slide2.slide)[resolve(\"right\")];\n          var left = rect(list)[resolve(\"left\")];\n          return abs(right - left) + (withoutGap ? 0 : getGap());\n        }\n        return 0;\n      }\n      function sliderSize(withoutGap) {\n        return totalSize(Splide2.length - 1) - totalSize(0) + slideSize(0, withoutGap);\n      }\n      function getGap() {\n        var Slide2 = getAt(0);\n        return Slide2 && parseFloat(style(Slide2.slide, resolve(\"marginRight\"))) || 0;\n      }\n      function getPadding(right) {\n        return parseFloat(style(track, resolve(\"padding\" + (right ? \"Right\" : \"Left\")))) || 0;\n      }\n      function isOverflow() {\n        return Splide2.is(FADE) || sliderSize(true) > listSize();\n      }\n      return {\n        mount,\n        resize,\n        listSize,\n        slideSize,\n        sliderSize,\n        totalSize,\n        getPadding,\n        isOverflow\n      };\n    }\n    var MULTIPLIER = 2;\n    function Clones(Splide2, Components2, options) {\n      var event = EventInterface(Splide2);\n      var on = event.on;\n      var Elements2 = Components2.Elements, Slides2 = Components2.Slides;\n      var resolve = Components2.Direction.resolve;\n      var clones = [];\n      var cloneCount;\n      function mount() {\n        on(EVENT_REFRESH, remount);\n        on([EVENT_UPDATED, EVENT_RESIZE], observe);\n        if (cloneCount = computeCloneCount()) {\n          generate(cloneCount);\n          Components2.Layout.resize(true);\n        }\n      }\n      function remount() {\n        destroy();\n        mount();\n      }\n      function destroy() {\n        remove(clones);\n        empty(clones);\n        event.destroy();\n      }\n      function observe() {\n        var count = computeCloneCount();\n        if (cloneCount !== count) {\n          if (cloneCount < count || !count) {\n            event.emit(EVENT_REFRESH);\n          }\n        }\n      }\n      function generate(count) {\n        var slides = Slides2.get().slice();\n        var length = slides.length;\n        if (length) {\n          while (slides.length < count) {\n            push(slides, slides);\n          }\n          push(slides.slice(-count), slides.slice(0, count)).forEach(function(Slide2, index) {\n            var isHead = index < count;\n            var clone = cloneDeep(Slide2.slide, index);\n            isHead ? before(clone, slides[0].slide) : append(Elements2.list, clone);\n            push(clones, clone);\n            Slides2.register(clone, index - count + (isHead ? 0 : length), Slide2.index);\n          });\n        }\n      }\n      function cloneDeep(elm, index) {\n        var clone = elm.cloneNode(true);\n        addClass(clone, options.classes.clone);\n        clone.id = Splide2.root.id + \"-clone\" + pad(index + 1);\n        return clone;\n      }\n      function computeCloneCount() {\n        var clones2 = options.clones;\n        if (!Splide2.is(LOOP)) {\n          clones2 = 0;\n        } else if (isUndefined(clones2)) {\n          var fixedSize = options[resolve(\"fixedWidth\")] && Components2.Layout.slideSize(0);\n          var fixedCount = fixedSize && ceil(rect(Elements2.track)[resolve(\"width\")] / fixedSize);\n          clones2 = fixedCount || options[resolve(\"autoWidth\")] && Splide2.length || options.perPage * MULTIPLIER;\n        }\n        return clones2;\n      }\n      return {\n        mount,\n        destroy\n      };\n    }\n    function Move(Splide2, Components2, options) {\n      var _EventInterface4 = EventInterface(Splide2), on = _EventInterface4.on, emit = _EventInterface4.emit;\n      var set = Splide2.state.set;\n      var _Components2$Layout = Components2.Layout, slideSize = _Components2$Layout.slideSize, getPadding = _Components2$Layout.getPadding, totalSize = _Components2$Layout.totalSize, listSize = _Components2$Layout.listSize, sliderSize = _Components2$Layout.sliderSize;\n      var _Components2$Directio = Components2.Direction, resolve = _Components2$Directio.resolve, orient = _Components2$Directio.orient;\n      var _Components2$Elements3 = Components2.Elements, list = _Components2$Elements3.list, track = _Components2$Elements3.track;\n      var Transition;\n      function mount() {\n        Transition = Components2.Transition;\n        on([EVENT_MOUNTED, EVENT_RESIZED, EVENT_UPDATED, EVENT_REFRESH], reposition);\n      }\n      function reposition() {\n        if (!Components2.Controller.isBusy()) {\n          Components2.Scroll.cancel();\n          jump(Splide2.index);\n          Components2.Slides.update();\n        }\n      }\n      function move(dest, index, prev, callback) {\n        if (dest !== index && canShift(dest > prev)) {\n          cancel();\n          translate(shift(getPosition(), dest > prev), true);\n        }\n        set(MOVING);\n        emit(EVENT_MOVE, index, prev, dest);\n        Transition.start(index, function() {\n          set(IDLE);\n          emit(EVENT_MOVED, index, prev, dest);\n          callback && callback();\n        });\n      }\n      function jump(index) {\n        translate(toPosition(index, true));\n      }\n      function translate(position, preventLoop) {\n        if (!Splide2.is(FADE)) {\n          var destination = preventLoop ? position : loop(position);\n          style(list, \"transform\", \"translate\" + resolve(\"X\") + \"(\" + destination + \"px)\");\n          position !== destination && emit(EVENT_SHIFTED);\n        }\n      }\n      function loop(position) {\n        if (Splide2.is(LOOP)) {\n          var index = toIndex(position);\n          var exceededMax = index > Components2.Controller.getEnd();\n          var exceededMin = index < 0;\n          if (exceededMin || exceededMax) {\n            position = shift(position, exceededMax);\n          }\n        }\n        return position;\n      }\n      function shift(position, backwards) {\n        var excess = position - getLimit(backwards);\n        var size = sliderSize();\n        position -= orient(size * (ceil(abs(excess) / size) || 1)) * (backwards ? 1 : -1);\n        return position;\n      }\n      function cancel() {\n        translate(getPosition(), true);\n        Transition.cancel();\n      }\n      function toIndex(position) {\n        var Slides2 = Components2.Slides.get();\n        var index = 0;\n        var minDistance = Infinity;\n        for (var i = 0; i < Slides2.length; i++) {\n          var slideIndex = Slides2[i].index;\n          var distance = abs(toPosition(slideIndex, true) - position);\n          if (distance <= minDistance) {\n            minDistance = distance;\n            index = slideIndex;\n          } else {\n            break;\n          }\n        }\n        return index;\n      }\n      function toPosition(index, trimming) {\n        var position = orient(totalSize(index - 1) - offset(index));\n        return trimming ? trim(position) : position;\n      }\n      function getPosition() {\n        var left = resolve(\"left\");\n        return rect(list)[left] - rect(track)[left] + orient(getPadding(false));\n      }\n      function trim(position) {\n        if (options.trimSpace && Splide2.is(SLIDE)) {\n          position = clamp(position, 0, orient(sliderSize(true) - listSize()));\n        }\n        return position;\n      }\n      function offset(index) {\n        var focus2 = options.focus;\n        return focus2 === \"center\" ? (listSize() - slideSize(index, true)) / 2 : +focus2 * slideSize(index) || 0;\n      }\n      function getLimit(max2) {\n        return toPosition(max2 ? Components2.Controller.getEnd() : 0, !!options.trimSpace);\n      }\n      function canShift(backwards) {\n        var shifted = orient(shift(getPosition(), backwards));\n        return backwards ? shifted >= 0 : shifted <= list[resolve(\"scrollWidth\")] - rect(track)[resolve(\"width\")];\n      }\n      function exceededLimit(max2, position) {\n        position = isUndefined(position) ? getPosition() : position;\n        var exceededMin = max2 !== true && orient(position) < orient(getLimit(false));\n        var exceededMax = max2 !== false && orient(position) > orient(getLimit(true));\n        return exceededMin || exceededMax;\n      }\n      return {\n        mount,\n        move,\n        jump,\n        translate,\n        shift,\n        cancel,\n        toIndex,\n        toPosition,\n        getPosition,\n        getLimit,\n        exceededLimit,\n        reposition\n      };\n    }\n    function Controller(Splide2, Components2, options) {\n      var _EventInterface5 = EventInterface(Splide2), on = _EventInterface5.on, emit = _EventInterface5.emit;\n      var Move2 = Components2.Move;\n      var getPosition = Move2.getPosition, getLimit = Move2.getLimit, toPosition = Move2.toPosition;\n      var _Components2$Slides = Components2.Slides, isEnough = _Components2$Slides.isEnough, getLength = _Components2$Slides.getLength;\n      var omitEnd = options.omitEnd;\n      var isLoop = Splide2.is(LOOP);\n      var isSlide = Splide2.is(SLIDE);\n      var getNext = apply(getAdjacent, false);\n      var getPrev = apply(getAdjacent, true);\n      var currIndex = options.start || 0;\n      var endIndex;\n      var prevIndex = currIndex;\n      var slideCount;\n      var perMove;\n      var perPage;\n      function mount() {\n        init();\n        on([EVENT_UPDATED, EVENT_REFRESH, EVENT_END_INDEX_CHANGED], init);\n        on(EVENT_RESIZED, onResized);\n      }\n      function init() {\n        slideCount = getLength(true);\n        perMove = options.perMove;\n        perPage = options.perPage;\n        endIndex = getEnd();\n        var index = clamp(currIndex, 0, omitEnd ? endIndex : slideCount - 1);\n        if (index !== currIndex) {\n          currIndex = index;\n          Move2.reposition();\n        }\n      }\n      function onResized() {\n        if (endIndex !== getEnd()) {\n          emit(EVENT_END_INDEX_CHANGED);\n        }\n      }\n      function go(control, allowSameIndex, callback) {\n        if (!isBusy()) {\n          var dest = parse(control);\n          var index = loop(dest);\n          if (index > -1 && (allowSameIndex || index !== currIndex)) {\n            setIndex(index);\n            Move2.move(dest, index, prevIndex, callback);\n          }\n        }\n      }\n      function scroll(destination, duration, snap, callback) {\n        Components2.Scroll.scroll(destination, duration, snap, function() {\n          var index = loop(Move2.toIndex(getPosition()));\n          setIndex(omitEnd ? min(index, endIndex) : index);\n          callback && callback();\n        });\n      }\n      function parse(control) {\n        var index = currIndex;\n        if (isString(control)) {\n          var _ref = control.match(/([+\\-<>])(\\d+)?/) || [], indicator = _ref[1], number = _ref[2];\n          if (indicator === \"+\" || indicator === \"-\") {\n            index = computeDestIndex(currIndex + +(\"\" + indicator + (+number || 1)), currIndex);\n          } else if (indicator === \">\") {\n            index = number ? toIndex(+number) : getNext(true);\n          } else if (indicator === \"<\") {\n            index = getPrev(true);\n          }\n        } else {\n          index = isLoop ? control : clamp(control, 0, endIndex);\n        }\n        return index;\n      }\n      function getAdjacent(prev, destination) {\n        var number = perMove || (hasFocus() ? 1 : perPage);\n        var dest = computeDestIndex(currIndex + number * (prev ? -1 : 1), currIndex, !(perMove || hasFocus()));\n        if (dest === -1 && isSlide) {\n          if (!approximatelyEqual(getPosition(), getLimit(!prev), 1)) {\n            return prev ? 0 : endIndex;\n          }\n        }\n        return destination ? dest : loop(dest);\n      }\n      function computeDestIndex(dest, from, snapPage) {\n        if (isEnough() || hasFocus()) {\n          var index = computeMovableDestIndex(dest);\n          if (index !== dest) {\n            from = dest;\n            dest = index;\n            snapPage = false;\n          }\n          if (dest < 0 || dest > endIndex) {\n            if (!perMove && (between(0, dest, from, true) || between(endIndex, from, dest, true))) {\n              dest = toIndex(toPage(dest));\n            } else {\n              if (isLoop) {\n                dest = snapPage ? dest < 0 ? -(slideCount % perPage || perPage) : slideCount : dest;\n              } else if (options.rewind) {\n                dest = dest < 0 ? endIndex : 0;\n              } else {\n                dest = -1;\n              }\n            }\n          } else {\n            if (snapPage && dest !== from) {\n              dest = toIndex(toPage(from) + (dest < from ? -1 : 1));\n            }\n          }\n        } else {\n          dest = -1;\n        }\n        return dest;\n      }\n      function computeMovableDestIndex(dest) {\n        if (isSlide && options.trimSpace === \"move\" && dest !== currIndex) {\n          var position = getPosition();\n          while (position === toPosition(dest, true) && between(dest, 0, Splide2.length - 1, !options.rewind)) {\n            dest < currIndex ? --dest : ++dest;\n          }\n        }\n        return dest;\n      }\n      function loop(index) {\n        return isLoop ? (index + slideCount) % slideCount || 0 : index;\n      }\n      function getEnd() {\n        var end = slideCount - (hasFocus() || isLoop && perMove ? 1 : perPage);\n        while (omitEnd && end-- > 0) {\n          if (toPosition(slideCount - 1, true) !== toPosition(end, true)) {\n            end++;\n            break;\n          }\n        }\n        return clamp(end, 0, slideCount - 1);\n      }\n      function toIndex(page) {\n        return clamp(hasFocus() ? page : perPage * page, 0, endIndex);\n      }\n      function toPage(index) {\n        return hasFocus() ? min(index, endIndex) : floor((index >= endIndex ? slideCount - 1 : index) / perPage);\n      }\n      function toDest(destination) {\n        var closest2 = Move2.toIndex(destination);\n        return isSlide ? clamp(closest2, 0, endIndex) : closest2;\n      }\n      function setIndex(index) {\n        if (index !== currIndex) {\n          prevIndex = currIndex;\n          currIndex = index;\n        }\n      }\n      function getIndex(prev) {\n        return prev ? prevIndex : currIndex;\n      }\n      function hasFocus() {\n        return !isUndefined(options.focus) || options.isNavigation;\n      }\n      function isBusy() {\n        return Splide2.state.is([MOVING, SCROLLING]) && !!options.waitForTransition;\n      }\n      return {\n        mount,\n        go,\n        scroll,\n        getNext,\n        getPrev,\n        getAdjacent,\n        getEnd,\n        setIndex,\n        getIndex,\n        toIndex,\n        toPage,\n        toDest,\n        hasFocus,\n        isBusy\n      };\n    }\n    var XML_NAME_SPACE = \"http://www.w3.org/2000/svg\";\n    var PATH = \"m15.5 0.932-4.3 4.38 14.5 14.6-14.5 14.5 4.3 4.4 14.6-14.6 4.4-4.3-4.4-4.4-14.6-14.6z\";\n    var SIZE = 40;\n    function Arrows(Splide2, Components2, options) {\n      var event = EventInterface(Splide2);\n      var on = event.on, bind = event.bind, emit = event.emit;\n      var classes = options.classes, i18n = options.i18n;\n      var Elements2 = Components2.Elements, Controller2 = Components2.Controller;\n      var placeholder = Elements2.arrows, track = Elements2.track;\n      var wrapper = placeholder;\n      var prev = Elements2.prev;\n      var next = Elements2.next;\n      var created;\n      var wrapperClasses;\n      var arrows = {};\n      function mount() {\n        init();\n        on(EVENT_UPDATED, remount);\n      }\n      function remount() {\n        destroy();\n        mount();\n      }\n      function init() {\n        var enabled = options.arrows;\n        if (enabled && !(prev && next)) {\n          createArrows();\n        }\n        if (prev && next) {\n          assign(arrows, {\n            prev,\n            next\n          });\n          display(wrapper, enabled ? \"\" : \"none\");\n          addClass(wrapper, wrapperClasses = CLASS_ARROWS + \"--\" + options.direction);\n          if (enabled) {\n            listen();\n            update();\n            setAttribute([prev, next], ARIA_CONTROLS, track.id);\n            emit(EVENT_ARROWS_MOUNTED, prev, next);\n          }\n        }\n      }\n      function destroy() {\n        event.destroy();\n        removeClass(wrapper, wrapperClasses);\n        if (created) {\n          remove(placeholder ? [prev, next] : wrapper);\n          prev = next = null;\n        } else {\n          removeAttribute([prev, next], ALL_ATTRIBUTES);\n        }\n      }\n      function listen() {\n        on([EVENT_MOUNTED, EVENT_MOVED, EVENT_REFRESH, EVENT_SCROLLED, EVENT_END_INDEX_CHANGED], update);\n        bind(next, \"click\", apply(go, \">\"));\n        bind(prev, \"click\", apply(go, \"<\"));\n      }\n      function go(control) {\n        Controller2.go(control, true);\n      }\n      function createArrows() {\n        wrapper = placeholder || create(\"div\", classes.arrows);\n        prev = createArrow(true);\n        next = createArrow(false);\n        created = true;\n        append(wrapper, [prev, next]);\n        !placeholder && before(wrapper, track);\n      }\n      function createArrow(prev2) {\n        var arrow = '<button class=\"' + classes.arrow + \" \" + (prev2 ? classes.prev : classes.next) + '\" type=\"button\"><svg xmlns=\"' + XML_NAME_SPACE + '\" viewBox=\"0 0 ' + SIZE + \" \" + SIZE + '\" width=\"' + SIZE + '\" height=\"' + SIZE + '\" focusable=\"false\"><path d=\"' + (options.arrowPath || PATH) + '\" />';\n        return parseHtml(arrow);\n      }\n      function update() {\n        if (prev && next) {\n          var index = Splide2.index;\n          var prevIndex = Controller2.getPrev();\n          var nextIndex = Controller2.getNext();\n          var prevLabel = prevIndex > -1 && index < prevIndex ? i18n.last : i18n.prev;\n          var nextLabel = nextIndex > -1 && index > nextIndex ? i18n.first : i18n.next;\n          prev.disabled = prevIndex < 0;\n          next.disabled = nextIndex < 0;\n          setAttribute(prev, ARIA_LABEL, prevLabel);\n          setAttribute(next, ARIA_LABEL, nextLabel);\n          emit(EVENT_ARROWS_UPDATED, prev, next, prevIndex, nextIndex);\n        }\n      }\n      return {\n        arrows,\n        mount,\n        destroy,\n        update\n      };\n    }\n    var INTERVAL_DATA_ATTRIBUTE = DATA_ATTRIBUTE + \"-interval\";\n    function Autoplay(Splide2, Components2, options) {\n      var _EventInterface6 = EventInterface(Splide2), on = _EventInterface6.on, bind = _EventInterface6.bind, emit = _EventInterface6.emit;\n      var interval = RequestInterval(options.interval, Splide2.go.bind(Splide2, \">\"), onAnimationFrame);\n      var isPaused = interval.isPaused;\n      var Elements2 = Components2.Elements, _Components2$Elements4 = Components2.Elements, root = _Components2$Elements4.root, toggle = _Components2$Elements4.toggle;\n      var autoplay = options.autoplay;\n      var hovered;\n      var focused;\n      var stopped = autoplay === \"pause\";\n      function mount() {\n        if (autoplay) {\n          listen();\n          toggle && setAttribute(toggle, ARIA_CONTROLS, Elements2.track.id);\n          stopped || play();\n          update();\n        }\n      }\n      function listen() {\n        if (options.pauseOnHover) {\n          bind(root, \"mouseenter mouseleave\", function(e) {\n            hovered = e.type === \"mouseenter\";\n            autoToggle();\n          });\n        }\n        if (options.pauseOnFocus) {\n          bind(root, \"focusin focusout\", function(e) {\n            focused = e.type === \"focusin\";\n            autoToggle();\n          });\n        }\n        if (toggle) {\n          bind(toggle, \"click\", function() {\n            stopped ? play() : pause(true);\n          });\n        }\n        on([EVENT_MOVE, EVENT_SCROLL, EVENT_REFRESH], interval.rewind);\n        on(EVENT_MOVE, onMove);\n      }\n      function play() {\n        if (isPaused() && Components2.Slides.isEnough()) {\n          interval.start(!options.resetProgress);\n          focused = hovered = stopped = false;\n          update();\n          emit(EVENT_AUTOPLAY_PLAY);\n        }\n      }\n      function pause(stop) {\n        if (stop === void 0) {\n          stop = true;\n        }\n        stopped = !!stop;\n        update();\n        if (!isPaused()) {\n          interval.pause();\n          emit(EVENT_AUTOPLAY_PAUSE);\n        }\n      }\n      function autoToggle() {\n        if (!stopped) {\n          hovered || focused ? pause(false) : play();\n        }\n      }\n      function update() {\n        if (toggle) {\n          toggleClass(toggle, CLASS_ACTIVE, !stopped);\n          setAttribute(toggle, ARIA_LABEL, options.i18n[stopped ? \"play\" : \"pause\"]);\n        }\n      }\n      function onAnimationFrame(rate) {\n        var bar = Elements2.bar;\n        bar && style(bar, \"width\", rate * 100 + \"%\");\n        emit(EVENT_AUTOPLAY_PLAYING, rate);\n      }\n      function onMove(index) {\n        var Slide2 = Components2.Slides.getAt(index);\n        interval.set(Slide2 && +getAttribute(Slide2.slide, INTERVAL_DATA_ATTRIBUTE) || options.interval);\n      }\n      return {\n        mount,\n        destroy: interval.cancel,\n        play,\n        pause,\n        isPaused\n      };\n    }\n    function Cover(Splide2, Components2, options) {\n      var _EventInterface7 = EventInterface(Splide2), on = _EventInterface7.on;\n      function mount() {\n        if (options.cover) {\n          on(EVENT_LAZYLOAD_LOADED, apply(toggle, true));\n          on([EVENT_MOUNTED, EVENT_UPDATED, EVENT_REFRESH], apply(cover, true));\n        }\n      }\n      function cover(cover2) {\n        Components2.Slides.forEach(function(Slide2) {\n          var img = child(Slide2.container || Slide2.slide, \"img\");\n          if (img && img.src) {\n            toggle(cover2, img, Slide2);\n          }\n        });\n      }\n      function toggle(cover2, img, Slide2) {\n        Slide2.style(\"background\", cover2 ? 'center/cover no-repeat url(\"' + img.src + '\")' : \"\", true);\n        display(img, cover2 ? \"none\" : \"\");\n      }\n      return {\n        mount,\n        destroy: apply(cover, false)\n      };\n    }\n    var BOUNCE_DIFF_THRESHOLD = 10;\n    var BOUNCE_DURATION = 600;\n    var FRICTION_FACTOR = 0.6;\n    var BASE_VELOCITY = 1.5;\n    var MIN_DURATION = 800;\n    function Scroll(Splide2, Components2, options) {\n      var _EventInterface8 = EventInterface(Splide2), on = _EventInterface8.on, emit = _EventInterface8.emit;\n      var set = Splide2.state.set;\n      var Move2 = Components2.Move;\n      var getPosition = Move2.getPosition, getLimit = Move2.getLimit, exceededLimit = Move2.exceededLimit, translate = Move2.translate;\n      var isSlide = Splide2.is(SLIDE);\n      var interval;\n      var callback;\n      var friction = 1;\n      function mount() {\n        on(EVENT_MOVE, clear);\n        on([EVENT_UPDATED, EVENT_REFRESH], cancel);\n      }\n      function scroll(destination, duration, snap, onScrolled, noConstrain) {\n        var from = getPosition();\n        clear();\n        if (snap && (!isSlide || !exceededLimit())) {\n          var size = Components2.Layout.sliderSize();\n          var offset = sign(destination) * size * floor(abs(destination) / size) || 0;\n          destination = Move2.toPosition(Components2.Controller.toDest(destination % size)) + offset;\n        }\n        var noDistance = approximatelyEqual(from, destination, 1);\n        friction = 1;\n        duration = noDistance ? 0 : duration || max(abs(destination - from) / BASE_VELOCITY, MIN_DURATION);\n        callback = onScrolled;\n        interval = RequestInterval(duration, onEnd, apply(update, from, destination, noConstrain), 1);\n        set(SCROLLING);\n        emit(EVENT_SCROLL);\n        interval.start();\n      }\n      function onEnd() {\n        set(IDLE);\n        callback && callback();\n        emit(EVENT_SCROLLED);\n      }\n      function update(from, to, noConstrain, rate) {\n        var position = getPosition();\n        var target = from + (to - from) * easing(rate);\n        var diff = (target - position) * friction;\n        translate(position + diff);\n        if (isSlide && !noConstrain && exceededLimit()) {\n          friction *= FRICTION_FACTOR;\n          if (abs(diff) < BOUNCE_DIFF_THRESHOLD) {\n            scroll(getLimit(exceededLimit(true)), BOUNCE_DURATION, false, callback, true);\n          }\n        }\n      }\n      function clear() {\n        if (interval) {\n          interval.cancel();\n        }\n      }\n      function cancel() {\n        if (interval && !interval.isPaused()) {\n          clear();\n          onEnd();\n        }\n      }\n      function easing(t) {\n        var easingFunc = options.easingFunc;\n        return easingFunc ? easingFunc(t) : 1 - Math.pow(1 - t, 4);\n      }\n      return {\n        mount,\n        destroy: clear,\n        scroll,\n        cancel\n      };\n    }\n    var SCROLL_LISTENER_OPTIONS = {\n      passive: false,\n      capture: true\n    };\n    function Drag(Splide2, Components2, options) {\n      var _EventInterface9 = EventInterface(Splide2), on = _EventInterface9.on, emit = _EventInterface9.emit, bind = _EventInterface9.bind, unbind = _EventInterface9.unbind;\n      var state = Splide2.state;\n      var Move2 = Components2.Move, Scroll2 = Components2.Scroll, Controller2 = Components2.Controller, track = Components2.Elements.track, reduce = Components2.Media.reduce;\n      var _Components2$Directio2 = Components2.Direction, resolve = _Components2$Directio2.resolve, orient = _Components2$Directio2.orient;\n      var getPosition = Move2.getPosition, exceededLimit = Move2.exceededLimit;\n      var basePosition;\n      var baseEvent;\n      var prevBaseEvent;\n      var isFree;\n      var dragging;\n      var exceeded = false;\n      var clickPrevented;\n      var disabled;\n      var target;\n      function mount() {\n        bind(track, POINTER_MOVE_EVENTS, noop, SCROLL_LISTENER_OPTIONS);\n        bind(track, POINTER_UP_EVENTS, noop, SCROLL_LISTENER_OPTIONS);\n        bind(track, POINTER_DOWN_EVENTS, onPointerDown, SCROLL_LISTENER_OPTIONS);\n        bind(track, \"click\", onClick, {\n          capture: true\n        });\n        bind(track, \"dragstart\", prevent);\n        on([EVENT_MOUNTED, EVENT_UPDATED], init);\n      }\n      function init() {\n        var drag = options.drag;\n        disable(!drag);\n        isFree = drag === \"free\";\n      }\n      function onPointerDown(e) {\n        clickPrevented = false;\n        if (!disabled) {\n          var isTouch = isTouchEvent(e);\n          if (isDraggable(e.target) && (isTouch || !e.button)) {\n            if (!Controller2.isBusy()) {\n              target = isTouch ? track : window;\n              dragging = state.is([MOVING, SCROLLING]);\n              prevBaseEvent = null;\n              bind(target, POINTER_MOVE_EVENTS, onPointerMove, SCROLL_LISTENER_OPTIONS);\n              bind(target, POINTER_UP_EVENTS, onPointerUp, SCROLL_LISTENER_OPTIONS);\n              Move2.cancel();\n              Scroll2.cancel();\n              save(e);\n            } else {\n              prevent(e, true);\n            }\n          }\n        }\n      }\n      function onPointerMove(e) {\n        if (!state.is(DRAGGING)) {\n          state.set(DRAGGING);\n          emit(EVENT_DRAG);\n        }\n        if (e.cancelable) {\n          if (dragging) {\n            Move2.translate(basePosition + constrain(diffCoord(e)));\n            var expired = diffTime(e) > LOG_INTERVAL;\n            var hasExceeded = exceeded !== (exceeded = exceededLimit());\n            if (expired || hasExceeded) {\n              save(e);\n            }\n            clickPrevented = true;\n            emit(EVENT_DRAGGING);\n            prevent(e);\n          } else if (isSliderDirection(e)) {\n            dragging = shouldStart(e);\n            prevent(e);\n          }\n        }\n      }\n      function onPointerUp(e) {\n        if (state.is(DRAGGING)) {\n          state.set(IDLE);\n          emit(EVENT_DRAGGED);\n        }\n        if (dragging) {\n          move(e);\n          prevent(e);\n        }\n        unbind(target, POINTER_MOVE_EVENTS, onPointerMove);\n        unbind(target, POINTER_UP_EVENTS, onPointerUp);\n        dragging = false;\n      }\n      function onClick(e) {\n        if (!disabled && clickPrevented) {\n          prevent(e, true);\n        }\n      }\n      function save(e) {\n        prevBaseEvent = baseEvent;\n        baseEvent = e;\n        basePosition = getPosition();\n      }\n      function move(e) {\n        var velocity = computeVelocity(e);\n        var destination = computeDestination(velocity);\n        var rewind = options.rewind && options.rewindByDrag;\n        reduce(false);\n        if (isFree) {\n          Controller2.scroll(destination, 0, options.snap);\n        } else if (Splide2.is(FADE)) {\n          Controller2.go(orient(sign(velocity)) < 0 ? rewind ? \"<\" : \"-\" : rewind ? \">\" : \"+\");\n        } else if (Splide2.is(SLIDE) && exceeded && rewind) {\n          Controller2.go(exceededLimit(true) ? \">\" : \"<\");\n        } else {\n          Controller2.go(Controller2.toDest(destination), true);\n        }\n        reduce(true);\n      }\n      function shouldStart(e) {\n        var thresholds = options.dragMinThreshold;\n        var isObj = isObject(thresholds);\n        var mouse = isObj && thresholds.mouse || 0;\n        var touch = (isObj ? thresholds.touch : +thresholds) || 10;\n        return abs(diffCoord(e)) > (isTouchEvent(e) ? touch : mouse);\n      }\n      function isSliderDirection(e) {\n        return abs(diffCoord(e)) > abs(diffCoord(e, true));\n      }\n      function computeVelocity(e) {\n        if (Splide2.is(LOOP) || !exceeded) {\n          var time = diffTime(e);\n          if (time && time < LOG_INTERVAL) {\n            return diffCoord(e) / time;\n          }\n        }\n        return 0;\n      }\n      function computeDestination(velocity) {\n        return getPosition() + sign(velocity) * min(abs(velocity) * (options.flickPower || 600), isFree ? Infinity : Components2.Layout.listSize() * (options.flickMaxPages || 1));\n      }\n      function diffCoord(e, orthogonal) {\n        return coordOf(e, orthogonal) - coordOf(getBaseEvent(e), orthogonal);\n      }\n      function diffTime(e) {\n        return timeOf(e) - timeOf(getBaseEvent(e));\n      }\n      function getBaseEvent(e) {\n        return baseEvent === e && prevBaseEvent || baseEvent;\n      }\n      function coordOf(e, orthogonal) {\n        return (isTouchEvent(e) ? e.changedTouches[0] : e)[\"page\" + resolve(orthogonal ? \"Y\" : \"X\")];\n      }\n      function constrain(diff) {\n        return diff / (exceeded && Splide2.is(SLIDE) ? FRICTION : 1);\n      }\n      function isDraggable(target2) {\n        var noDrag = options.noDrag;\n        return !matches(target2, \".\" + CLASS_PAGINATION_PAGE + \", .\" + CLASS_ARROW) && (!noDrag || !matches(target2, noDrag));\n      }\n      function isTouchEvent(e) {\n        return typeof TouchEvent !== \"undefined\" && e instanceof TouchEvent;\n      }\n      function isDragging() {\n        return dragging;\n      }\n      function disable(value) {\n        disabled = value;\n      }\n      return {\n        mount,\n        disable,\n        isDragging\n      };\n    }\n    var NORMALIZATION_MAP = {\n      Spacebar: \" \",\n      Right: ARROW_RIGHT,\n      Left: ARROW_LEFT,\n      Up: ARROW_UP,\n      Down: ARROW_DOWN\n    };\n    function normalizeKey(key) {\n      key = isString(key) ? key : key.key;\n      return NORMALIZATION_MAP[key] || key;\n    }\n    var KEYBOARD_EVENT = \"keydown\";\n    function Keyboard(Splide2, Components2, options) {\n      var _EventInterface10 = EventInterface(Splide2), on = _EventInterface10.on, bind = _EventInterface10.bind, unbind = _EventInterface10.unbind;\n      var root = Splide2.root;\n      var resolve = Components2.Direction.resolve;\n      var target;\n      var disabled;\n      function mount() {\n        init();\n        on(EVENT_UPDATED, destroy);\n        on(EVENT_UPDATED, init);\n        on(EVENT_MOVE, onMove);\n      }\n      function init() {\n        var keyboard = options.keyboard;\n        if (keyboard) {\n          target = keyboard === \"global\" ? window : root;\n          bind(target, KEYBOARD_EVENT, onKeydown);\n        }\n      }\n      function destroy() {\n        unbind(target, KEYBOARD_EVENT);\n      }\n      function disable(value) {\n        disabled = value;\n      }\n      function onMove() {\n        var _disabled = disabled;\n        disabled = true;\n        nextTick(function() {\n          disabled = _disabled;\n        });\n      }\n      function onKeydown(e) {\n        if (!disabled) {\n          var key = normalizeKey(e);\n          if (key === resolve(ARROW_LEFT)) {\n            Splide2.go(\"<\");\n          } else if (key === resolve(ARROW_RIGHT)) {\n            Splide2.go(\">\");\n          }\n        }\n      }\n      return {\n        mount,\n        destroy,\n        disable\n      };\n    }\n    var SRC_DATA_ATTRIBUTE = DATA_ATTRIBUTE + \"-lazy\";\n    var SRCSET_DATA_ATTRIBUTE = SRC_DATA_ATTRIBUTE + \"-srcset\";\n    var IMAGE_SELECTOR = \"[\" + SRC_DATA_ATTRIBUTE + \"], [\" + SRCSET_DATA_ATTRIBUTE + \"]\";\n    function LazyLoad(Splide2, Components2, options) {\n      var _EventInterface11 = EventInterface(Splide2), on = _EventInterface11.on, off = _EventInterface11.off, bind = _EventInterface11.bind, emit = _EventInterface11.emit;\n      var isSequential = options.lazyLoad === \"sequential\";\n      var events = [EVENT_MOVED, EVENT_SCROLLED];\n      var entries = [];\n      function mount() {\n        if (options.lazyLoad) {\n          init();\n          on(EVENT_REFRESH, init);\n        }\n      }\n      function init() {\n        empty(entries);\n        register();\n        if (isSequential) {\n          loadNext();\n        } else {\n          off(events);\n          on(events, check);\n          check();\n        }\n      }\n      function register() {\n        Components2.Slides.forEach(function(Slide2) {\n          queryAll(Slide2.slide, IMAGE_SELECTOR).forEach(function(img) {\n            var src = getAttribute(img, SRC_DATA_ATTRIBUTE);\n            var srcset = getAttribute(img, SRCSET_DATA_ATTRIBUTE);\n            if (src !== img.src || srcset !== img.srcset) {\n              var className = options.classes.spinner;\n              var parent = img.parentElement;\n              var spinner = child(parent, \".\" + className) || create(\"span\", className, parent);\n              entries.push([img, Slide2, spinner]);\n              img.src || display(img, \"none\");\n            }\n          });\n        });\n      }\n      function check() {\n        entries = entries.filter(function(data) {\n          var distance = options.perPage * ((options.preloadPages || 1) + 1) - 1;\n          return data[1].isWithin(Splide2.index, distance) ? load(data) : true;\n        });\n        entries.length || off(events);\n      }\n      function load(data) {\n        var img = data[0];\n        addClass(data[1].slide, CLASS_LOADING);\n        bind(img, \"load error\", apply(onLoad, data));\n        setAttribute(img, \"src\", getAttribute(img, SRC_DATA_ATTRIBUTE));\n        setAttribute(img, \"srcset\", getAttribute(img, SRCSET_DATA_ATTRIBUTE));\n        removeAttribute(img, SRC_DATA_ATTRIBUTE);\n        removeAttribute(img, SRCSET_DATA_ATTRIBUTE);\n      }\n      function onLoad(data, e) {\n        var img = data[0], Slide2 = data[1];\n        removeClass(Slide2.slide, CLASS_LOADING);\n        if (e.type !== \"error\") {\n          remove(data[2]);\n          display(img, \"\");\n          emit(EVENT_LAZYLOAD_LOADED, img, Slide2);\n          emit(EVENT_RESIZE);\n        }\n        isSequential && loadNext();\n      }\n      function loadNext() {\n        entries.length && load(entries.shift());\n      }\n      return {\n        mount,\n        destroy: apply(empty, entries),\n        check\n      };\n    }\n    function Pagination(Splide2, Components2, options) {\n      var event = EventInterface(Splide2);\n      var on = event.on, emit = event.emit, bind = event.bind;\n      var Slides2 = Components2.Slides, Elements2 = Components2.Elements, Controller2 = Components2.Controller;\n      var hasFocus = Controller2.hasFocus, getIndex = Controller2.getIndex, go = Controller2.go;\n      var resolve = Components2.Direction.resolve;\n      var placeholder = Elements2.pagination;\n      var items = [];\n      var list;\n      var paginationClasses;\n      function mount() {\n        destroy();\n        on([EVENT_UPDATED, EVENT_REFRESH, EVENT_END_INDEX_CHANGED], mount);\n        var enabled = options.pagination;\n        placeholder && display(placeholder, enabled ? \"\" : \"none\");\n        if (enabled) {\n          on([EVENT_MOVE, EVENT_SCROLL, EVENT_SCROLLED], update);\n          createPagination();\n          update();\n          emit(EVENT_PAGINATION_MOUNTED, {\n            list,\n            items\n          }, getAt(Splide2.index));\n        }\n      }\n      function destroy() {\n        if (list) {\n          remove(placeholder ? slice(list.children) : list);\n          removeClass(list, paginationClasses);\n          empty(items);\n          list = null;\n        }\n        event.destroy();\n      }\n      function createPagination() {\n        var length = Splide2.length;\n        var classes = options.classes, i18n = options.i18n, perPage = options.perPage;\n        var max2 = hasFocus() ? Controller2.getEnd() + 1 : ceil(length / perPage);\n        list = placeholder || create(\"ul\", classes.pagination, Elements2.track.parentElement);\n        addClass(list, paginationClasses = CLASS_PAGINATION + \"--\" + getDirection());\n        setAttribute(list, ROLE, \"tablist\");\n        setAttribute(list, ARIA_LABEL, i18n.select);\n        setAttribute(list, ARIA_ORIENTATION, getDirection() === TTB ? \"vertical\" : \"\");\n        for (var i = 0; i < max2; i++) {\n          var li = create(\"li\", null, list);\n          var button = create(\"button\", {\n            class: classes.page,\n            type: \"button\"\n          }, li);\n          var controls = Slides2.getIn(i).map(function(Slide2) {\n            return Slide2.slide.id;\n          });\n          var text = !hasFocus() && perPage > 1 ? i18n.pageX : i18n.slideX;\n          bind(button, \"click\", apply(onClick, i));\n          if (options.paginationKeyboard) {\n            bind(button, \"keydown\", apply(onKeydown, i));\n          }\n          setAttribute(li, ROLE, \"presentation\");\n          setAttribute(button, ROLE, \"tab\");\n          setAttribute(button, ARIA_CONTROLS, controls.join(\" \"));\n          setAttribute(button, ARIA_LABEL, format(text, i + 1));\n          setAttribute(button, TAB_INDEX, -1);\n          items.push({\n            li,\n            button,\n            page: i\n          });\n        }\n      }\n      function onClick(page) {\n        go(\">\" + page, true);\n      }\n      function onKeydown(page, e) {\n        var length = items.length;\n        var key = normalizeKey(e);\n        var dir = getDirection();\n        var nextPage = -1;\n        if (key === resolve(ARROW_RIGHT, false, dir)) {\n          nextPage = ++page % length;\n        } else if (key === resolve(ARROW_LEFT, false, dir)) {\n          nextPage = (--page + length) % length;\n        } else if (key === \"Home\") {\n          nextPage = 0;\n        } else if (key === \"End\") {\n          nextPage = length - 1;\n        }\n        var item = items[nextPage];\n        if (item) {\n          focus(item.button);\n          go(\">\" + nextPage);\n          prevent(e, true);\n        }\n      }\n      function getDirection() {\n        return options.paginationDirection || options.direction;\n      }\n      function getAt(index) {\n        return items[Controller2.toPage(index)];\n      }\n      function update() {\n        var prev = getAt(getIndex(true));\n        var curr = getAt(getIndex());\n        if (prev) {\n          var button = prev.button;\n          removeClass(button, CLASS_ACTIVE);\n          removeAttribute(button, ARIA_SELECTED);\n          setAttribute(button, TAB_INDEX, -1);\n        }\n        if (curr) {\n          var _button = curr.button;\n          addClass(_button, CLASS_ACTIVE);\n          setAttribute(_button, ARIA_SELECTED, true);\n          setAttribute(_button, TAB_INDEX, \"\");\n        }\n        emit(EVENT_PAGINATION_UPDATED, {\n          list,\n          items\n        }, prev, curr);\n      }\n      return {\n        items,\n        mount,\n        destroy,\n        getAt,\n        update\n      };\n    }\n    var TRIGGER_KEYS = [\" \", \"Enter\"];\n    function Sync(Splide2, Components2, options) {\n      var isNavigation = options.isNavigation, slideFocus = options.slideFocus;\n      var events = [];\n      function mount() {\n        Splide2.splides.forEach(function(target) {\n          if (!target.isParent) {\n            sync(Splide2, target.splide);\n            sync(target.splide, Splide2);\n          }\n        });\n        if (isNavigation) {\n          navigate();\n        }\n      }\n      function destroy() {\n        events.forEach(function(event) {\n          event.destroy();\n        });\n        empty(events);\n      }\n      function remount() {\n        destroy();\n        mount();\n      }\n      function sync(splide, target) {\n        var event = EventInterface(splide);\n        event.on(EVENT_MOVE, function(index, prev, dest) {\n          target.go(target.is(LOOP) ? dest : index);\n        });\n        events.push(event);\n      }\n      function navigate() {\n        var event = EventInterface(Splide2);\n        var on = event.on;\n        on(EVENT_CLICK, onClick);\n        on(EVENT_SLIDE_KEYDOWN, onKeydown);\n        on([EVENT_MOUNTED, EVENT_UPDATED], update);\n        events.push(event);\n        event.emit(EVENT_NAVIGATION_MOUNTED, Splide2.splides);\n      }\n      function update() {\n        setAttribute(Components2.Elements.list, ARIA_ORIENTATION, options.direction === TTB ? \"vertical\" : \"\");\n      }\n      function onClick(Slide2) {\n        Splide2.go(Slide2.index);\n      }\n      function onKeydown(Slide2, e) {\n        if (includes(TRIGGER_KEYS, normalizeKey(e))) {\n          onClick(Slide2);\n          prevent(e);\n        }\n      }\n      return {\n        setup: apply(Components2.Media.set, {\n          slideFocus: isUndefined(slideFocus) ? isNavigation : slideFocus\n        }, true),\n        mount,\n        destroy,\n        remount\n      };\n    }\n    function Wheel(Splide2, Components2, options) {\n      var _EventInterface12 = EventInterface(Splide2), bind = _EventInterface12.bind;\n      var lastTime = 0;\n      function mount() {\n        if (options.wheel) {\n          bind(Components2.Elements.track, \"wheel\", onWheel, SCROLL_LISTENER_OPTIONS);\n        }\n      }\n      function onWheel(e) {\n        if (e.cancelable) {\n          var deltaY = e.deltaY;\n          var backwards = deltaY < 0;\n          var timeStamp = timeOf(e);\n          var _min = options.wheelMinThreshold || 0;\n          var sleep = options.wheelSleep || 0;\n          if (abs(deltaY) > _min && timeStamp - lastTime > sleep) {\n            Splide2.go(backwards ? \"<\" : \">\");\n            lastTime = timeStamp;\n          }\n          shouldPrevent(backwards) && prevent(e);\n        }\n      }\n      function shouldPrevent(backwards) {\n        return !options.releaseWheel || Splide2.state.is(MOVING) || Components2.Controller.getAdjacent(backwards) !== -1;\n      }\n      return {\n        mount\n      };\n    }\n    var SR_REMOVAL_DELAY = 90;\n    function Live(Splide2, Components2, options) {\n      var _EventInterface13 = EventInterface(Splide2), on = _EventInterface13.on;\n      var track = Components2.Elements.track;\n      var enabled = options.live && !options.isNavigation;\n      var sr = create(\"span\", CLASS_SR);\n      var interval = RequestInterval(SR_REMOVAL_DELAY, apply(toggle, false));\n      function mount() {\n        if (enabled) {\n          disable(!Components2.Autoplay.isPaused());\n          setAttribute(track, ARIA_ATOMIC, true);\n          sr.textContent = \"\\u2026\";\n          on(EVENT_AUTOPLAY_PLAY, apply(disable, true));\n          on(EVENT_AUTOPLAY_PAUSE, apply(disable, false));\n          on([EVENT_MOVED, EVENT_SCROLLED], apply(toggle, true));\n        }\n      }\n      function toggle(active) {\n        setAttribute(track, ARIA_BUSY, active);\n        if (active) {\n          append(track, sr);\n          interval.start();\n        } else {\n          remove(sr);\n          interval.cancel();\n        }\n      }\n      function destroy() {\n        removeAttribute(track, [ARIA_LIVE, ARIA_ATOMIC, ARIA_BUSY]);\n        remove(sr);\n      }\n      function disable(disabled) {\n        if (enabled) {\n          setAttribute(track, ARIA_LIVE, disabled ? \"off\" : \"polite\");\n        }\n      }\n      return {\n        mount,\n        disable,\n        destroy\n      };\n    }\n    var ComponentConstructors = /* @__PURE__ */ Object.freeze({\n      __proto__: null,\n      Media,\n      Direction,\n      Elements,\n      Slides,\n      Layout,\n      Clones,\n      Move,\n      Controller,\n      Arrows,\n      Autoplay,\n      Cover,\n      Scroll,\n      Drag,\n      Keyboard,\n      LazyLoad,\n      Pagination,\n      Sync,\n      Wheel,\n      Live\n    });\n    var I18N = {\n      prev: \"Previous slide\",\n      next: \"Next slide\",\n      first: \"Go to first slide\",\n      last: \"Go to last slide\",\n      slideX: \"Go to slide %s\",\n      pageX: \"Go to page %s\",\n      play: \"Start autoplay\",\n      pause: \"Pause autoplay\",\n      carousel: \"carousel\",\n      slide: \"slide\",\n      select: \"Select a slide to show\",\n      slideLabel: \"%s of %s\"\n    };\n    var DEFAULTS = {\n      type: \"slide\",\n      role: \"region\",\n      speed: 400,\n      perPage: 1,\n      cloneStatus: true,\n      arrows: true,\n      pagination: true,\n      paginationKeyboard: true,\n      interval: 5e3,\n      pauseOnHover: true,\n      pauseOnFocus: true,\n      resetProgress: true,\n      easing: \"cubic-bezier(0.25, 1, 0.5, 1)\",\n      drag: true,\n      direction: \"ltr\",\n      trimSpace: true,\n      focusableNodes: \"a, button, textarea, input, select, iframe\",\n      live: true,\n      classes: CLASSES,\n      i18n: I18N,\n      reducedMotion: {\n        speed: 0,\n        rewindSpeed: 0,\n        autoplay: \"pause\"\n      }\n    };\n    function Fade(Splide2, Components2, options) {\n      var Slides2 = Components2.Slides;\n      function mount() {\n        EventInterface(Splide2).on([EVENT_MOUNTED, EVENT_REFRESH], init);\n      }\n      function init() {\n        Slides2.forEach(function(Slide2) {\n          Slide2.style(\"transform\", \"translateX(-\" + 100 * Slide2.index + \"%)\");\n        });\n      }\n      function start(index, done) {\n        Slides2.style(\"transition\", \"opacity \" + options.speed + \"ms \" + options.easing);\n        nextTick(done);\n      }\n      return {\n        mount,\n        start,\n        cancel: noop\n      };\n    }\n    function Slide(Splide2, Components2, options) {\n      var Move2 = Components2.Move, Controller2 = Components2.Controller, Scroll2 = Components2.Scroll;\n      var list = Components2.Elements.list;\n      var transition = apply(style, list, \"transition\");\n      var endCallback;\n      function mount() {\n        EventInterface(Splide2).bind(list, \"transitionend\", function(e) {\n          if (e.target === list && endCallback) {\n            cancel();\n            endCallback();\n          }\n        });\n      }\n      function start(index, done) {\n        var destination = Move2.toPosition(index, true);\n        var position = Move2.getPosition();\n        var speed = getSpeed(index);\n        if (abs(destination - position) >= 1 && speed >= 1) {\n          if (options.useScroll) {\n            Scroll2.scroll(destination, speed, false, done);\n          } else {\n            transition(\"transform \" + speed + \"ms \" + options.easing);\n            Move2.translate(destination, true);\n            endCallback = done;\n          }\n        } else {\n          Move2.jump(index);\n          done();\n        }\n      }\n      function cancel() {\n        transition(\"\");\n        Scroll2.cancel();\n      }\n      function getSpeed(index) {\n        var rewindSpeed = options.rewindSpeed;\n        if (Splide2.is(SLIDE) && rewindSpeed) {\n          var prev = Controller2.getIndex(true);\n          var end = Controller2.getEnd();\n          if (prev === 0 && index >= end || prev >= end && index === 0) {\n            return rewindSpeed;\n          }\n        }\n        return options.speed;\n      }\n      return {\n        mount,\n        start,\n        cancel\n      };\n    }\n    var _Splide = /* @__PURE__ */ function() {\n      function _Splide2(target, options) {\n        this.event = EventInterface();\n        this.Components = {};\n        this.state = State(CREATED);\n        this.splides = [];\n        this._o = {};\n        this._E = {};\n        var root = isString(target) ? query(document, target) : target;\n        assert(root, root + \" is invalid.\");\n        this.root = root;\n        options = merge({\n          label: getAttribute(root, ARIA_LABEL) || \"\",\n          labelledby: getAttribute(root, ARIA_LABELLEDBY) || \"\"\n        }, DEFAULTS, _Splide2.defaults, options || {});\n        try {\n          merge(options, JSON.parse(getAttribute(root, DATA_ATTRIBUTE)));\n        } catch (e) {\n          assert(false, \"Invalid JSON\");\n        }\n        this._o = Object.create(merge({}, options));\n      }\n      var _proto = _Splide2.prototype;\n      _proto.mount = function mount(Extensions, Transition) {\n        var _this = this;\n        var state = this.state, Components2 = this.Components;\n        assert(state.is([CREATED, DESTROYED]), \"Already mounted!\");\n        state.set(CREATED);\n        this._C = Components2;\n        this._T = Transition || this._T || (this.is(FADE) ? Fade : Slide);\n        this._E = Extensions || this._E;\n        var Constructors = assign({}, ComponentConstructors, this._E, {\n          Transition: this._T\n        });\n        forOwn(Constructors, function(Component, key) {\n          var component = Component(_this, Components2, _this._o);\n          Components2[key] = component;\n          component.setup && component.setup();\n        });\n        forOwn(Components2, function(component) {\n          component.mount && component.mount();\n        });\n        this.emit(EVENT_MOUNTED);\n        addClass(this.root, CLASS_INITIALIZED);\n        state.set(IDLE);\n        this.emit(EVENT_READY);\n        return this;\n      };\n      _proto.sync = function sync(splide) {\n        this.splides.push({\n          splide\n        });\n        splide.splides.push({\n          splide: this,\n          isParent: true\n        });\n        if (this.state.is(IDLE)) {\n          this._C.Sync.remount();\n          splide.Components.Sync.remount();\n        }\n        return this;\n      };\n      _proto.go = function go(control) {\n        this._C.Controller.go(control);\n        return this;\n      };\n      _proto.on = function on(events, callback) {\n        this.event.on(events, callback);\n        return this;\n      };\n      _proto.off = function off(events) {\n        this.event.off(events);\n        return this;\n      };\n      _proto.emit = function emit(event) {\n        var _this$event;\n        (_this$event = this.event).emit.apply(_this$event, [event].concat(slice(arguments, 1)));\n        return this;\n      };\n      _proto.add = function add(slides, index) {\n        this._C.Slides.add(slides, index);\n        return this;\n      };\n      _proto.remove = function remove2(matcher) {\n        this._C.Slides.remove(matcher);\n        return this;\n      };\n      _proto.is = function is(type) {\n        return this._o.type === type;\n      };\n      _proto.refresh = function refresh() {\n        this.emit(EVENT_REFRESH);\n        return this;\n      };\n      _proto.destroy = function destroy(completely) {\n        if (completely === void 0) {\n          completely = true;\n        }\n        var event = this.event, state = this.state;\n        if (state.is(CREATED)) {\n          EventInterface(this).on(EVENT_READY, this.destroy.bind(this, completely));\n        } else {\n          forOwn(this._C, function(component) {\n            component.destroy && component.destroy(completely);\n          }, true);\n          event.emit(EVENT_DESTROY);\n          event.destroy();\n          completely && empty(this.splides);\n          state.set(DESTROYED);\n        }\n        return this;\n      };\n      _createClass(_Splide2, [{\n        key: \"options\",\n        get: function get() {\n          return this._o;\n        },\n        set: function set(options) {\n          this._C.Media.set(options, true, true);\n        }\n      }, {\n        key: \"length\",\n        get: function get() {\n          return this._C.Slides.getLength(true);\n        }\n      }, {\n        key: \"index\",\n        get: function get() {\n          return this._C.Controller.getIndex();\n        }\n      }]);\n      return _Splide2;\n    }();\n    var Splide = _Splide;\n    Splide.defaults = {};\n    Splide.STATES = STATES;\n    return Splide;\n  });\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (carouselSplideInit);\n\n\n//# sourceURL=webpack:///./modules/carousel-splide.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./main.js");
/******/ 	
/******/ })()
;